/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationCodeConfigurationObservation struct {
}

type ApplicationCodeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CodeContent []CodeContentParameters `json:"codeContent,omitempty" tf:"code_content,omitempty"`

	// +kubebuilder:validation:Required
	CodeContentType *string `json:"codeContentType" tf:"code_content_type,omitempty"`
}

type ApplicationConfigurationObservation struct {
	SQLApplicationConfiguration []SQLApplicationConfigurationObservation `json:"sqlApplicationConfiguration,omitempty" tf:"sql_application_configuration,omitempty"`

	VPCConfiguration []VPCConfigurationObservation `json:"vpcConfiguration,omitempty" tf:"vpc_configuration,omitempty"`
}

type ApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ApplicationCodeConfiguration []ApplicationCodeConfigurationParameters `json:"applicationCodeConfiguration" tf:"application_code_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationSnapshotConfiguration []ApplicationSnapshotConfigurationParameters `json:"applicationSnapshotConfiguration,omitempty" tf:"application_snapshot_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentProperties []EnvironmentPropertiesParameters `json:"environmentProperties,omitempty" tf:"environment_properties,omitempty"`

	// +kubebuilder:validation:Optional
	FlinkApplicationConfiguration []FlinkApplicationConfigurationParameters `json:"flinkApplicationConfiguration,omitempty" tf:"flink_application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	RunConfiguration []RunConfigurationParameters `json:"runConfiguration,omitempty" tf:"run_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	SQLApplicationConfiguration []SQLApplicationConfigurationParameters `json:"sqlApplicationConfiguration,omitempty" tf:"sql_application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	VPCConfiguration []VPCConfigurationParameters `json:"vpcConfiguration,omitempty" tf:"vpc_configuration,omitempty"`
}

type ApplicationObservation struct {
	ApplicationConfiguration []ApplicationConfigurationObservation `json:"applicationConfiguration,omitempty" tf:"application_configuration,omitempty"`

	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	CloudwatchLoggingOptions []CloudwatchLoggingOptionsObservation `json:"cloudwatchLoggingOptions,omitempty" tf:"cloudwatch_logging_options,omitempty"`

	CreateTimestamp *string `json:"createTimestamp,omitempty" tf:"create_timestamp,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LastUpdateTimestamp *string `json:"lastUpdateTimestamp,omitempty" tf:"last_update_timestamp,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	VersionID *float64 `json:"versionId,omitempty" tf:"version_id,omitempty"`
}

type ApplicationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationConfiguration []ApplicationConfigurationParameters `json:"applicationConfiguration,omitempty" tf:"application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	CloudwatchLoggingOptions []CloudwatchLoggingOptionsParameters `json:"cloudwatchLoggingOptions,omitempty" tf:"cloudwatch_logging_options,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	ForceStop *bool `json:"forceStop,omitempty" tf:"force_stop,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	RuntimeEnvironment *string `json:"runtimeEnvironment" tf:"runtime_environment,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	ServiceExecutionRole *string `json:"serviceExecutionRole,omitempty" tf:"service_execution_role,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceExecutionRoleRef *v1.Reference `json:"serviceExecutionRoleRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ServiceExecutionRoleSelector *v1.Selector `json:"serviceExecutionRoleSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	StartApplication *bool `json:"startApplication,omitempty" tf:"start_application,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ApplicationRestoreConfigurationObservation struct {
}

type ApplicationRestoreConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationRestoreType *string `json:"applicationRestoreType,omitempty" tf:"application_restore_type,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotName *string `json:"snapshotName,omitempty" tf:"snapshot_name,omitempty"`
}

type ApplicationSnapshotConfigurationObservation struct {
}

type ApplicationSnapshotConfigurationParameters struct {

	// +kubebuilder:validation:Required
	SnapshotsEnabled *bool `json:"snapshotsEnabled" tf:"snapshots_enabled,omitempty"`
}

type CheckpointConfigurationObservation struct {
}

type CheckpointConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CheckpointInterval *float64 `json:"checkpointInterval,omitempty" tf:"checkpoint_interval,omitempty"`

	// +kubebuilder:validation:Optional
	CheckpointingEnabled *bool `json:"checkpointingEnabled,omitempty" tf:"checkpointing_enabled,omitempty"`

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	MinPauseBetweenCheckpoints *float64 `json:"minPauseBetweenCheckpoints,omitempty" tf:"min_pause_between_checkpoints,omitempty"`
}

type CloudwatchLoggingOptionsObservation struct {
	CloudwatchLoggingOptionID *string `json:"cloudwatchLoggingOptionId,omitempty" tf:"cloudwatch_logging_option_id,omitempty"`
}

type CloudwatchLoggingOptionsParameters struct {

	// +kubebuilder:validation:Required
	LogStreamArn *string `json:"logStreamArn" tf:"log_stream_arn,omitempty"`
}

type CodeContentObservation struct {
}

type CodeContentParameters struct {

	// +kubebuilder:validation:Optional
	S3ContentLocation []S3ContentLocationParameters `json:"s3ContentLocation,omitempty" tf:"s3_content_location,omitempty"`

	// +kubebuilder:validation:Optional
	TextContent *string `json:"textContent,omitempty" tf:"text_content,omitempty"`
}

type CsvMappingParametersObservation struct {
}

type CsvMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordColumnDelimiter *string `json:"recordColumnDelimiter" tf:"record_column_delimiter,omitempty"`

	// +kubebuilder:validation:Required
	RecordRowDelimiter *string `json:"recordRowDelimiter" tf:"record_row_delimiter,omitempty"`
}

type DestinationSchemaObservation struct {
}

type DestinationSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type EnvironmentPropertiesObservation struct {
}

type EnvironmentPropertiesParameters struct {

	// +kubebuilder:validation:Required
	PropertyGroup []PropertyGroupParameters `json:"propertyGroup" tf:"property_group,omitempty"`
}

type FlinkApplicationConfigurationObservation struct {
}

type FlinkApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CheckpointConfiguration []CheckpointConfigurationParameters `json:"checkpointConfiguration,omitempty" tf:"checkpoint_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	MonitoringConfiguration []MonitoringConfigurationParameters `json:"monitoringConfiguration,omitempty" tf:"monitoring_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	ParallelismConfiguration []ParallelismConfigurationParameters `json:"parallelismConfiguration,omitempty" tf:"parallelism_configuration,omitempty"`
}

type FlinkRunConfigurationObservation struct {
}

type FlinkRunConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AllowNonRestoredState *bool `json:"allowNonRestoredState,omitempty" tf:"allow_non_restored_state,omitempty"`
}

type InputLambdaProcessorObservation struct {
}

type InputLambdaProcessorParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type InputObservation struct {
	InAppStreamNames []*string `json:"inAppStreamNames,omitempty" tf:"in_app_stream_names,omitempty"`

	InputID *string `json:"inputId,omitempty" tf:"input_id,omitempty"`
}

type InputParallelismObservation struct {
}

type InputParallelismParameters struct {

	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`
}

type InputParameters struct {

	// +kubebuilder:validation:Optional
	InputParallelism []InputParallelismParameters `json:"inputParallelism,omitempty" tf:"input_parallelism,omitempty"`

	// +kubebuilder:validation:Optional
	InputProcessingConfiguration []InputProcessingConfigurationParameters `json:"inputProcessingConfiguration,omitempty" tf:"input_processing_configuration,omitempty"`

	// +kubebuilder:validation:Required
	InputSchema []InputSchemaParameters `json:"inputSchema" tf:"input_schema,omitempty"`

	// +kubebuilder:validation:Optional
	InputStartingPositionConfiguration []InputStartingPositionConfigurationParameters `json:"inputStartingPositionConfiguration,omitempty" tf:"input_starting_position_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisFirehoseInput []KinesisFirehoseInputParameters `json:"kinesisFirehoseInput,omitempty" tf:"kinesis_firehose_input,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisStreamsInput []KinesisStreamsInputParameters `json:"kinesisStreamsInput,omitempty" tf:"kinesis_streams_input,omitempty"`

	// +kubebuilder:validation:Required
	NamePrefix *string `json:"namePrefix" tf:"name_prefix,omitempty"`
}

type InputProcessingConfigurationObservation struct {
}

type InputProcessingConfigurationParameters struct {

	// +kubebuilder:validation:Required
	InputLambdaProcessor []InputLambdaProcessorParameters `json:"inputLambdaProcessor" tf:"input_lambda_processor,omitempty"`
}

type InputSchemaObservation struct {
}

type InputSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordColumn []RecordColumnParameters `json:"recordColumn" tf:"record_column,omitempty"`

	// +kubebuilder:validation:Optional
	RecordEncoding *string `json:"recordEncoding,omitempty" tf:"record_encoding,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormat []RecordFormatParameters `json:"recordFormat" tf:"record_format,omitempty"`
}

type InputStartingPositionConfigurationObservation struct {
}

type InputStartingPositionConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	InputStartingPosition *string `json:"inputStartingPosition,omitempty" tf:"input_starting_position,omitempty"`
}

type JSONMappingParametersObservation struct {
}

type JSONMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordRowPath *string `json:"recordRowPath" tf:"record_row_path,omitempty"`
}

type KinesisFirehoseInputObservation struct {
}

type KinesisFirehoseInputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type KinesisFirehoseOutputObservation struct {
}

type KinesisFirehoseOutputParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/firehose/v1beta1.DeliveryStream
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("arn",false)
	// +kubebuilder:validation:Optional
	ResourceArn *string `json:"resourceArn,omitempty" tf:"resource_arn,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceArnRef *v1.Reference `json:"resourceArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceArnSelector *v1.Selector `json:"resourceArnSelector,omitempty" tf:"-"`
}

type KinesisStreamsInputObservation struct {
}

type KinesisStreamsInputParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/kinesis/v1beta1.Stream
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("arn",false)
	// +kubebuilder:validation:Optional
	ResourceArn *string `json:"resourceArn,omitempty" tf:"resource_arn,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceArnRef *v1.Reference `json:"resourceArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceArnSelector *v1.Selector `json:"resourceArnSelector,omitempty" tf:"-"`
}

type KinesisStreamsOutputObservation struct {
}

type KinesisStreamsOutputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type LambdaOutputObservation struct {
}

type LambdaOutputParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/lambda/v1beta1.Function
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("arn",true)
	// +kubebuilder:validation:Optional
	ResourceArn *string `json:"resourceArn,omitempty" tf:"resource_arn,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceArnRef *v1.Reference `json:"resourceArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceArnSelector *v1.Selector `json:"resourceArnSelector,omitempty" tf:"-"`
}

type MappingParametersCsvMappingParametersObservation struct {
}

type MappingParametersCsvMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordColumnDelimiter *string `json:"recordColumnDelimiter" tf:"record_column_delimiter,omitempty"`

	// +kubebuilder:validation:Required
	RecordRowDelimiter *string `json:"recordRowDelimiter" tf:"record_row_delimiter,omitempty"`
}

type MappingParametersJSONMappingParametersObservation struct {
}

type MappingParametersJSONMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordRowPath *string `json:"recordRowPath" tf:"record_row_path,omitempty"`
}

type MappingParametersObservation struct {
}

type MappingParametersParameters struct {

	// +kubebuilder:validation:Optional
	CsvMappingParameters []CsvMappingParametersParameters `json:"csvMappingParameters,omitempty" tf:"csv_mapping_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	JSONMappingParameters []JSONMappingParametersParameters `json:"jsonMappingParameters,omitempty" tf:"json_mapping_parameters,omitempty"`
}

type MonitoringConfigurationObservation struct {
}

type MonitoringConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	LogLevel *string `json:"logLevel,omitempty" tf:"log_level,omitempty"`

	// +kubebuilder:validation:Optional
	MetricsLevel *string `json:"metricsLevel,omitempty" tf:"metrics_level,omitempty"`
}

type OutputObservation struct {
	OutputID *string `json:"outputId,omitempty" tf:"output_id,omitempty"`
}

type OutputParameters struct {

	// +kubebuilder:validation:Required
	DestinationSchema []DestinationSchemaParameters `json:"destinationSchema" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisFirehoseOutput []KinesisFirehoseOutputParameters `json:"kinesisFirehoseOutput,omitempty" tf:"kinesis_firehose_output,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisStreamsOutput []KinesisStreamsOutputParameters `json:"kinesisStreamsOutput,omitempty" tf:"kinesis_streams_output,omitempty"`

	// +kubebuilder:validation:Optional
	LambdaOutput []LambdaOutputParameters `json:"lambdaOutput,omitempty" tf:"lambda_output,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type ParallelismConfigurationObservation struct {
}

type ParallelismConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AutoScalingEnabled *bool `json:"autoScalingEnabled,omitempty" tf:"auto_scaling_enabled,omitempty"`

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	Parallelism *float64 `json:"parallelism,omitempty" tf:"parallelism,omitempty"`

	// +kubebuilder:validation:Optional
	ParallelismPerKpu *float64 `json:"parallelismPerKpu,omitempty" tf:"parallelism_per_kpu,omitempty"`
}

type PropertyGroupObservation struct {
}

type PropertyGroupParameters struct {

	// +kubebuilder:validation:Required
	PropertyGroupID *string `json:"propertyGroupId" tf:"property_group_id,omitempty"`

	// +kubebuilder:validation:Required
	PropertyMap map[string]*string `json:"propertyMap" tf:"property_map,omitempty"`
}

type RecordColumnObservation struct {
}

type RecordColumnParameters struct {

	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	SQLType *string `json:"sqlType" tf:"sql_type,omitempty"`
}

type RecordFormatMappingParametersObservation struct {
}

type RecordFormatMappingParametersParameters struct {

	// +kubebuilder:validation:Optional
	CsvMappingParameters []MappingParametersCsvMappingParametersParameters `json:"csvMappingParameters,omitempty" tf:"csv_mapping_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	JSONMappingParameters []MappingParametersJSONMappingParametersParameters `json:"jsonMappingParameters,omitempty" tf:"json_mapping_parameters,omitempty"`
}

type RecordFormatObservation struct {
}

type RecordFormatParameters struct {

	// +kubebuilder:validation:Required
	MappingParameters []MappingParametersParameters `json:"mappingParameters" tf:"mapping_parameters,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type ReferenceDataSourceObservation struct {
	ReferenceID *string `json:"referenceId,omitempty" tf:"reference_id,omitempty"`
}

type ReferenceDataSourceParameters struct {

	// +kubebuilder:validation:Required
	ReferenceSchema []ReferenceSchemaParameters `json:"referenceSchema" tf:"reference_schema,omitempty"`

	// +kubebuilder:validation:Required
	S3ReferenceDataSource []S3ReferenceDataSourceParameters `json:"s3ReferenceDataSource" tf:"s3_reference_data_source,omitempty"`

	// +kubebuilder:validation:Required
	TableName *string `json:"tableName" tf:"table_name,omitempty"`
}

type ReferenceSchemaObservation struct {
}

type ReferenceSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordColumn []ReferenceSchemaRecordColumnParameters `json:"recordColumn" tf:"record_column,omitempty"`

	// +kubebuilder:validation:Optional
	RecordEncoding *string `json:"recordEncoding,omitempty" tf:"record_encoding,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormat []ReferenceSchemaRecordFormatParameters `json:"recordFormat" tf:"record_format,omitempty"`
}

type ReferenceSchemaRecordColumnObservation struct {
}

type ReferenceSchemaRecordColumnParameters struct {

	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	SQLType *string `json:"sqlType" tf:"sql_type,omitempty"`
}

type ReferenceSchemaRecordFormatObservation struct {
}

type ReferenceSchemaRecordFormatParameters struct {

	// +kubebuilder:validation:Required
	MappingParameters []RecordFormatMappingParametersParameters `json:"mappingParameters" tf:"mapping_parameters,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type RunConfigurationObservation struct {
}

type RunConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationRestoreConfiguration []ApplicationRestoreConfigurationParameters `json:"applicationRestoreConfiguration,omitempty" tf:"application_restore_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	FlinkRunConfiguration []FlinkRunConfigurationParameters `json:"flinkRunConfiguration,omitempty" tf:"flink_run_configuration,omitempty"`
}

type S3ContentLocationObservation struct {
}

type S3ContentLocationParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/s3/v1beta1.Bucket
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	BucketArn *string `json:"bucketArn,omitempty" tf:"bucket_arn,omitempty"`

	// +kubebuilder:validation:Optional
	BucketArnRef *v1.Reference `json:"bucketArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BucketArnSelector *v1.Selector `json:"bucketArnSelector,omitempty" tf:"-"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/s3/v1beta1.Object
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("key",false)
	// +kubebuilder:validation:Optional
	FileKey *string `json:"fileKey,omitempty" tf:"file_key,omitempty"`

	// +kubebuilder:validation:Optional
	FileKeyRef *v1.Reference `json:"fileKeyRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	FileKeySelector *v1.Selector `json:"fileKeySelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ObjectVersion *string `json:"objectVersion,omitempty" tf:"object_version,omitempty"`
}

type S3ReferenceDataSourceObservation struct {
}

type S3ReferenceDataSourceParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/s3/v1beta1.Bucket
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("arn",false)
	// +kubebuilder:validation:Optional
	BucketArn *string `json:"bucketArn,omitempty" tf:"bucket_arn,omitempty"`

	// +kubebuilder:validation:Optional
	BucketArnRef *v1.Reference `json:"bucketArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BucketArnSelector *v1.Selector `json:"bucketArnSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	FileKey *string `json:"fileKey" tf:"file_key,omitempty"`
}

type SQLApplicationConfigurationObservation struct {
	Input []InputObservation `json:"input,omitempty" tf:"input,omitempty"`

	Output []OutputObservation `json:"output,omitempty" tf:"output,omitempty"`

	ReferenceDataSource []ReferenceDataSourceObservation `json:"referenceDataSource,omitempty" tf:"reference_data_source,omitempty"`
}

type SQLApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Input []InputParameters `json:"input,omitempty" tf:"input,omitempty"`

	// +kubebuilder:validation:Optional
	Output []OutputParameters `json:"output,omitempty" tf:"output,omitempty"`

	// +kubebuilder:validation:Optional
	ReferenceDataSource []ReferenceDataSourceParameters `json:"referenceDataSource,omitempty" tf:"reference_data_source,omitempty"`
}

type VPCConfigurationObservation struct {
	VPCConfigurationID *string `json:"vpcConfigurationId,omitempty" tf:"vpc_configuration_id,omitempty"`

	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type VPCConfigurationParameters struct {

	// +kubebuilder:validation:Required
	SecurityGroupIds []*string `json:"securityGroupIds" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`
}

// ApplicationSpec defines the desired state of Application
type ApplicationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ApplicationParameters `json:"forProvider"`
}

// ApplicationStatus defines the observed state of Application.
type ApplicationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ApplicationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Application is the Schema for the Applications API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Application struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ApplicationSpec   `json:"spec"`
	Status            ApplicationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ApplicationList contains a list of Applications
type ApplicationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Application `json:"items"`
}

// Repository type metadata.
var (
	Application_Kind             = "Application"
	Application_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Application_Kind}.String()
	Application_KindAPIVersion   = Application_Kind + "." + CRDGroupVersion.String()
	Application_GroupVersionKind = CRDGroupVersion.WithKind(Application_Kind)
)

func init() {
	SchemeBuilder.Register(&Application{}, &ApplicationList{})
}

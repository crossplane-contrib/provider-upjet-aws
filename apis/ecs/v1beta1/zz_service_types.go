// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlarmsInitParameters struct {

	// One or more CloudWatch alarm names.
	// +listType=set
	AlarmNames []*string `json:"alarmNames,omitempty" tf:"alarm_names,omitempty"`

	// Determines whether to use the CloudWatch alarm option in the service deployment process.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	Rollback *bool `json:"rollback,omitempty" tf:"rollback,omitempty"`
}

type AlarmsObservation struct {

	// One or more CloudWatch alarm names.
	// +listType=set
	AlarmNames []*string `json:"alarmNames,omitempty" tf:"alarm_names,omitempty"`

	// Determines whether to use the CloudWatch alarm option in the service deployment process.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	Rollback *bool `json:"rollback,omitempty" tf:"rollback,omitempty"`
}

type AlarmsParameters struct {

	// One or more CloudWatch alarm names.
	// +kubebuilder:validation:Optional
	// +listType=set
	AlarmNames []*string `json:"alarmNames" tf:"alarm_names,omitempty"`

	// Determines whether to use the CloudWatch alarm option in the service deployment process.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable" tf:"enable,omitempty"`

	// Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	// +kubebuilder:validation:Optional
	Rollback *bool `json:"rollback" tf:"rollback,omitempty"`
}

type CapacityProviderStrategyInitParameters struct {

	// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
	Base *float64 `json:"base,omitempty" tf:"base,omitempty"`

	// Short name of the capacity provider.
	CapacityProvider *string `json:"capacityProvider,omitempty" tf:"capacity_provider,omitempty"`

	// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type CapacityProviderStrategyObservation struct {

	// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
	Base *float64 `json:"base,omitempty" tf:"base,omitempty"`

	// Short name of the capacity provider.
	CapacityProvider *string `json:"capacityProvider,omitempty" tf:"capacity_provider,omitempty"`

	// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type CapacityProviderStrategyParameters struct {

	// Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
	// +kubebuilder:validation:Optional
	Base *float64 `json:"base,omitempty" tf:"base,omitempty"`

	// Short name of the capacity provider.
	// +kubebuilder:validation:Optional
	CapacityProvider *string `json:"capacityProvider" tf:"capacity_provider,omitempty"`

	// Relative percentage of the total number of launched tasks that should use the specified capacity provider.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type ClientAliasInitParameters struct {

	// The name that you use in the applications of client tasks to connect to this service.
	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	// The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type ClientAliasObservation struct {

	// The name that you use in the applications of client tasks to connect to this service.
	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	// The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type ClientAliasParameters struct {

	// The name that you use in the applications of client tasks to connect to this service.
	// +kubebuilder:validation:Optional
	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	// The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port" tf:"port,omitempty"`
}

type DeploymentCircuitBreakerInitParameters struct {

	// Whether to enable the deployment circuit breaker logic for the service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	Rollback *bool `json:"rollback,omitempty" tf:"rollback,omitempty"`
}

type DeploymentCircuitBreakerObservation struct {

	// Whether to enable the deployment circuit breaker logic for the service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	Rollback *bool `json:"rollback,omitempty" tf:"rollback,omitempty"`
}

type DeploymentCircuitBreakerParameters struct {

	// Whether to enable the deployment circuit breaker logic for the service.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable" tf:"enable,omitempty"`

	// Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
	// +kubebuilder:validation:Optional
	Rollback *bool `json:"rollback" tf:"rollback,omitempty"`
}

type DeploymentControllerInitParameters struct {

	// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DeploymentControllerObservation struct {

	// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DeploymentControllerParameters struct {

	// Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type IssuerCertAuthorityInitParameters struct {

	// The ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
	AwsPcaAuthorityArn *string `json:"awsPcaAuthorityArn,omitempty" tf:"aws_pca_authority_arn,omitempty"`
}

type IssuerCertAuthorityObservation struct {

	// The ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
	AwsPcaAuthorityArn *string `json:"awsPcaAuthorityArn,omitempty" tf:"aws_pca_authority_arn,omitempty"`
}

type IssuerCertAuthorityParameters struct {

	// The ARN of the aws_acmpca_certificate_authority used to create the TLS Certificates.
	// +kubebuilder:validation:Optional
	AwsPcaAuthorityArn *string `json:"awsPcaAuthorityArn" tf:"aws_pca_authority_arn,omitempty"`
}

type LoadBalancerInitParameters struct {

	// Name of the container to associate with the load balancer (as it appears in a container definition).
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// Port on the container to associate with the load balancer.
	ContainerPort *float64 `json:"containerPort,omitempty" tf:"container_port,omitempty"`

	// Name of the ELB (Classic) to associate with the service.
	ELBName *string `json:"elbName,omitempty" tf:"elb_name,omitempty"`

	// ARN of the Load Balancer target group to associate with the service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/elbv2/v1beta1.LBTargetGroup
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`

	// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
	// +kubebuilder:validation:Optional
	TargetGroupArnRef *v1.Reference `json:"targetGroupArnRef,omitempty" tf:"-"`

	// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
	// +kubebuilder:validation:Optional
	TargetGroupArnSelector *v1.Selector `json:"targetGroupArnSelector,omitempty" tf:"-"`
}

type LoadBalancerObservation struct {

	// Name of the container to associate with the load balancer (as it appears in a container definition).
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// Port on the container to associate with the load balancer.
	ContainerPort *float64 `json:"containerPort,omitempty" tf:"container_port,omitempty"`

	// Name of the ELB (Classic) to associate with the service.
	ELBName *string `json:"elbName,omitempty" tf:"elb_name,omitempty"`

	// ARN of the Load Balancer target group to associate with the service.
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`
}

type LoadBalancerParameters struct {

	// Name of the container to associate with the load balancer (as it appears in a container definition).
	// +kubebuilder:validation:Optional
	ContainerName *string `json:"containerName" tf:"container_name,omitempty"`

	// Port on the container to associate with the load balancer.
	// +kubebuilder:validation:Optional
	ContainerPort *float64 `json:"containerPort" tf:"container_port,omitempty"`

	// Name of the ELB (Classic) to associate with the service.
	// +kubebuilder:validation:Optional
	ELBName *string `json:"elbName,omitempty" tf:"elb_name,omitempty"`

	// ARN of the Load Balancer target group to associate with the service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/elbv2/v1beta1.LBTargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`

	// Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
	// +kubebuilder:validation:Optional
	TargetGroupArnRef *v1.Reference `json:"targetGroupArnRef,omitempty" tf:"-"`

	// Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
	// +kubebuilder:validation:Optional
	TargetGroupArnSelector *v1.Selector `json:"targetGroupArnSelector,omitempty" tf:"-"`
}

type NetworkConfigurationInitParameters struct {

	// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// References to SecurityGroup in ec2 to populate securityGroups.
	// +kubebuilder:validation:Optional
	SecurityGroupRefs []v1.Reference `json:"securityGroupRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
	// +kubebuilder:validation:Optional
	SecurityGroupSelector *v1.Selector `json:"securityGroupSelector,omitempty" tf:"-"`

	// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/ec2/v1beta1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupSelector
	// +listType=set
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// References to Subnet in ec2 to populate subnets.
	// +kubebuilder:validation:Optional
	SubnetRefs []v1.Reference `json:"subnetRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in ec2 to populate subnets.
	// +kubebuilder:validation:Optional
	SubnetSelector *v1.Selector `json:"subnetSelector,omitempty" tf:"-"`

	// Subnets associated with the task or service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/ec2/v1beta1.Subnet
	// +crossplane:generate:reference:refFieldName=SubnetRefs
	// +crossplane:generate:reference:selectorFieldName=SubnetSelector
	// +listType=set
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type NetworkConfigurationObservation struct {

	// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
	// +listType=set
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// Subnets associated with the task or service.
	// +listType=set
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type NetworkConfigurationParameters struct {

	// Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// References to SecurityGroup in ec2 to populate securityGroups.
	// +kubebuilder:validation:Optional
	SecurityGroupRefs []v1.Reference `json:"securityGroupRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ec2 to populate securityGroups.
	// +kubebuilder:validation:Optional
	SecurityGroupSelector *v1.Selector `json:"securityGroupSelector,omitempty" tf:"-"`

	// Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/ec2/v1beta1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupSelector
	// +kubebuilder:validation:Optional
	// +listType=set
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// References to Subnet in ec2 to populate subnets.
	// +kubebuilder:validation:Optional
	SubnetRefs []v1.Reference `json:"subnetRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in ec2 to populate subnets.
	// +kubebuilder:validation:Optional
	SubnetSelector *v1.Selector `json:"subnetSelector,omitempty" tf:"-"`

	// Subnets associated with the task or service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/ec2/v1beta1.Subnet
	// +crossplane:generate:reference:refFieldName=SubnetRefs
	// +crossplane:generate:reference:selectorFieldName=SubnetSelector
	// +kubebuilder:validation:Optional
	// +listType=set
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type OrderedPlacementStrategyInitParameters struct {

	// For the spread placement strategy, valid values are instanceId (or host,
	// which has the same effect), or any platform or custom attribute that is applied to a container instance.
	// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
	// needed. For more information, see Placement Strategy.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Type of placement strategy. Must be one of: binpack, random, or spread
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OrderedPlacementStrategyObservation struct {

	// For the spread placement strategy, valid values are instanceId (or host,
	// which has the same effect), or any platform or custom attribute that is applied to a container instance.
	// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
	// needed. For more information, see Placement Strategy.
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Type of placement strategy. Must be one of: binpack, random, or spread
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OrderedPlacementStrategyParameters struct {

	// For the spread placement strategy, valid values are instanceId (or host,
	// which has the same effect), or any platform or custom attribute that is applied to a container instance.
	// For the binpack type, valid values are memory and cpu. For the random type, this attribute is not
	// needed. For more information, see Placement Strategy.
	// +kubebuilder:validation:Optional
	Field *string `json:"field,omitempty" tf:"field,omitempty"`

	// Type of placement strategy. Must be one of: binpack, random, or spread
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type PlacementConstraintsInitParameters struct {

	// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type PlacementConstraintsObservation struct {

	// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type PlacementConstraintsParameters struct {

	// Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// Type of constraint. The only valid values at this time are memberOf and distinctInstance.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type SecretOptionInitParameters struct {

	// The name of the secret.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
	ValueFrom *string `json:"valueFrom,omitempty" tf:"value_from,omitempty"`
}

type SecretOptionObservation struct {

	// The name of the secret.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
	ValueFrom *string `json:"valueFrom,omitempty" tf:"value_from,omitempty"`
}

type SecretOptionParameters struct {

	// The name of the secret.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
	// +kubebuilder:validation:Optional
	ValueFrom *string `json:"valueFrom" tf:"value_from,omitempty"`
}

type ServiceConnectConfigurationInitParameters struct {

	// Specifies whether to use Service Connect with this service.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The log configuration for the container. See below.
	LogConfiguration []ServiceConnectConfigurationLogConfigurationInitParameters `json:"logConfiguration,omitempty" tf:"log_configuration,omitempty"`

	// The namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The list of Service Connect service objects. See below.
	Service []ServiceConnectConfigurationServiceInitParameters `json:"service,omitempty" tf:"service,omitempty"`
}

type ServiceConnectConfigurationLogConfigurationInitParameters struct {

	// The log driver to use for the container.
	LogDriver *string `json:"logDriver,omitempty" tf:"log_driver,omitempty"`

	// The configuration options to send to the log driver.
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The secrets to pass to the log configuration. See below.
	SecretOption []SecretOptionInitParameters `json:"secretOption,omitempty" tf:"secret_option,omitempty"`
}

type ServiceConnectConfigurationLogConfigurationObservation struct {

	// The log driver to use for the container.
	LogDriver *string `json:"logDriver,omitempty" tf:"log_driver,omitempty"`

	// The configuration options to send to the log driver.
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The secrets to pass to the log configuration. See below.
	SecretOption []SecretOptionObservation `json:"secretOption,omitempty" tf:"secret_option,omitempty"`
}

type ServiceConnectConfigurationLogConfigurationParameters struct {

	// The log driver to use for the container.
	// +kubebuilder:validation:Optional
	LogDriver *string `json:"logDriver" tf:"log_driver,omitempty"`

	// The configuration options to send to the log driver.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The secrets to pass to the log configuration. See below.
	// +kubebuilder:validation:Optional
	SecretOption []SecretOptionParameters `json:"secretOption,omitempty" tf:"secret_option,omitempty"`
}

type ServiceConnectConfigurationObservation struct {

	// Specifies whether to use Service Connect with this service.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The log configuration for the container. See below.
	LogConfiguration []ServiceConnectConfigurationLogConfigurationObservation `json:"logConfiguration,omitempty" tf:"log_configuration,omitempty"`

	// The namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The list of Service Connect service objects. See below.
	Service []ServiceConnectConfigurationServiceObservation `json:"service,omitempty" tf:"service,omitempty"`
}

type ServiceConnectConfigurationParameters struct {

	// Specifies whether to use Service Connect with this service.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// The log configuration for the container. See below.
	// +kubebuilder:validation:Optional
	LogConfiguration []ServiceConnectConfigurationLogConfigurationParameters `json:"logConfiguration,omitempty" tf:"log_configuration,omitempty"`

	// The namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The list of Service Connect service objects. See below.
	// +kubebuilder:validation:Optional
	Service []ServiceConnectConfigurationServiceParameters `json:"service,omitempty" tf:"service,omitempty"`
}

type ServiceConnectConfigurationServiceInitParameters struct {

	// The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
	ClientAlias []ClientAliasInitParameters `json:"clientAlias,omitempty" tf:"client_alias,omitempty"`

	// The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
	DiscoveryName *string `json:"discoveryName,omitempty" tf:"discovery_name,omitempty"`

	// The port number for the Service Connect proxy to listen on.
	IngressPortOverride *float64 `json:"ingressPortOverride,omitempty" tf:"ingress_port_override,omitempty"`

	// The name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The configuration for enabling Transport Layer Security (TLS)
	TLS []TLSInitParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// Configuration timeouts for Service Connect
	Timeout []TimeoutInitParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ServiceConnectConfigurationServiceObservation struct {

	// The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
	ClientAlias []ClientAliasObservation `json:"clientAlias,omitempty" tf:"client_alias,omitempty"`

	// The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
	DiscoveryName *string `json:"discoveryName,omitempty" tf:"discovery_name,omitempty"`

	// The port number for the Service Connect proxy to listen on.
	IngressPortOverride *float64 `json:"ingressPortOverride,omitempty" tf:"ingress_port_override,omitempty"`

	// The name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The configuration for enabling Transport Layer Security (TLS)
	TLS []TLSObservation `json:"tls,omitempty" tf:"tls,omitempty"`

	// Configuration timeouts for Service Connect
	Timeout []TimeoutObservation `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ServiceConnectConfigurationServiceParameters struct {

	// The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
	// +kubebuilder:validation:Optional
	ClientAlias []ClientAliasParameters `json:"clientAlias,omitempty" tf:"client_alias,omitempty"`

	// The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
	// +kubebuilder:validation:Optional
	DiscoveryName *string `json:"discoveryName,omitempty" tf:"discovery_name,omitempty"`

	// The port number for the Service Connect proxy to listen on.
	// +kubebuilder:validation:Optional
	IngressPortOverride *float64 `json:"ingressPortOverride,omitempty" tf:"ingress_port_override,omitempty"`

	// The name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
	// +kubebuilder:validation:Optional
	PortName *string `json:"portName" tf:"port_name,omitempty"`

	// The configuration for enabling Transport Layer Security (TLS)
	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// Configuration timeouts for Service Connect
	// +kubebuilder:validation:Optional
	Timeout []TimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ServiceInitParameters struct {

	// Information about the CloudWatch alarms. See below.
	Alarms []AlarmsInitParameters `json:"alarms,omitempty" tf:"alarms,omitempty"`

	// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
	CapacityProviderStrategy []CapacityProviderStrategyInitParameters `json:"capacityProviderStrategy,omitempty" tf:"capacity_provider_strategy,omitempty"`

	// Name of an ECS cluster.
	// +crossplane:generate:reference:type=Cluster
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Reference to a Cluster to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.Reference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.Selector `json:"clusterSelector,omitempty" tf:"-"`

	// Configuration block for deployment circuit breaker. See below.
	DeploymentCircuitBreaker []DeploymentCircuitBreakerInitParameters `json:"deploymentCircuitBreaker,omitempty" tf:"deployment_circuit_breaker,omitempty"`

	// Configuration block for deployment controller configuration. See below.
	DeploymentController []DeploymentControllerInitParameters `json:"deploymentController,omitempty" tf:"deployment_controller,omitempty"`

	// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
	DeploymentMaximumPercent *float64 `json:"deploymentMaximumPercent,omitempty" tf:"deployment_maximum_percent,omitempty"`

	// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
	DeploymentMinimumHealthyPercent *float64 `json:"deploymentMinimumHealthyPercent,omitempty" tf:"deployment_minimum_healthy_percent,omitempty"`

	// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
	DesiredCount *float64 `json:"desiredCount,omitempty" tf:"desired_count,omitempty"`

	// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
	EnableEcsManagedTags *bool `json:"enableEcsManagedTags,omitempty" tf:"enable_ecs_managed_tags,omitempty"`

	// Specifies whether to enable Amazon ECS Exec for the tasks within the service.
	EnableExecuteCommand *bool `json:"enableExecuteCommand,omitempty" tf:"enable_execute_command,omitempty"`

	// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
	ForceNewDeployment *bool `json:"forceNewDeployment,omitempty" tf:"force_new_deployment,omitempty"`

	// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
	HealthCheckGracePeriodSeconds *float64 `json:"healthCheckGracePeriodSeconds,omitempty" tf:"health_check_grace_period_seconds,omitempty"`

	// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-aws/config/common.ARNExtractor()
	IAMRole *string `json:"iamRole,omitempty" tf:"iam_role,omitempty"`

	// Reference to a Role in iam to populate iamRole.
	// +kubebuilder:validation:Optional
	IAMRoleRef *v1.Reference `json:"iamRoleRef,omitempty" tf:"-"`

	// Selector for a Role in iam to populate iamRole.
	// +kubebuilder:validation:Optional
	IAMRoleSelector *v1.Selector `json:"iamRoleSelector,omitempty" tf:"-"`

	// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
	LaunchType *string `json:"launchType,omitempty" tf:"launch_type,omitempty"`

	// Configuration block for load balancers. See below.
	LoadBalancer []LoadBalancerInitParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
	NetworkConfiguration []NetworkConfigurationInitParameters `json:"networkConfiguration,omitempty" tf:"network_configuration,omitempty"`

	// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
	OrderedPlacementStrategy []OrderedPlacementStrategyInitParameters `json:"orderedPlacementStrategy,omitempty" tf:"ordered_placement_strategy,omitempty"`

	// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
	PlacementConstraints []PlacementConstraintsInitParameters `json:"placementConstraints,omitempty" tf:"placement_constraints,omitempty"`

	// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
	PlatformVersion *string `json:"platformVersion,omitempty" tf:"platform_version,omitempty"`

	// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
	PropagateTags *string `json:"propagateTags,omitempty" tf:"propagate_tags,omitempty"`

	// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
	SchedulingStrategy *string `json:"schedulingStrategy,omitempty" tf:"scheduling_strategy,omitempty"`

	// The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
	ServiceConnectConfiguration []ServiceConnectConfigurationInitParameters `json:"serviceConnectConfiguration,omitempty" tf:"service_connect_configuration,omitempty"`

	// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
	ServiceRegistries []ServiceRegistriesInitParameters `json:"serviceRegistries,omitempty" tf:"service_registries,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
	// +crossplane:generate:reference:type=TaskDefinition
	TaskDefinition *string `json:"taskDefinition,omitempty" tf:"task_definition,omitempty"`

	// Reference to a TaskDefinition to populate taskDefinition.
	// +kubebuilder:validation:Optional
	TaskDefinitionRef *v1.Reference `json:"taskDefinitionRef,omitempty" tf:"-"`

	// Selector for a TaskDefinition to populate taskDefinition.
	// +kubebuilder:validation:Optional
	TaskDefinitionSelector *v1.Selector `json:"taskDefinitionSelector,omitempty" tf:"-"`

	// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
	// +mapType=granular
	Triggers map[string]*string `json:"triggers,omitempty" tf:"triggers,omitempty"`

	// Default false.
	WaitForSteadyState *bool `json:"waitForSteadyState,omitempty" tf:"wait_for_steady_state,omitempty"`
}

type ServiceObservation struct {

	// Information about the CloudWatch alarms. See below.
	Alarms []AlarmsObservation `json:"alarms,omitempty" tf:"alarms,omitempty"`

	// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
	CapacityProviderStrategy []CapacityProviderStrategyObservation `json:"capacityProviderStrategy,omitempty" tf:"capacity_provider_strategy,omitempty"`

	// Name of an ECS cluster.
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Configuration block for deployment circuit breaker. See below.
	DeploymentCircuitBreaker []DeploymentCircuitBreakerObservation `json:"deploymentCircuitBreaker,omitempty" tf:"deployment_circuit_breaker,omitempty"`

	// Configuration block for deployment controller configuration. See below.
	DeploymentController []DeploymentControllerObservation `json:"deploymentController,omitempty" tf:"deployment_controller,omitempty"`

	// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
	DeploymentMaximumPercent *float64 `json:"deploymentMaximumPercent,omitempty" tf:"deployment_maximum_percent,omitempty"`

	// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
	DeploymentMinimumHealthyPercent *float64 `json:"deploymentMinimumHealthyPercent,omitempty" tf:"deployment_minimum_healthy_percent,omitempty"`

	// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
	DesiredCount *float64 `json:"desiredCount,omitempty" tf:"desired_count,omitempty"`

	// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
	EnableEcsManagedTags *bool `json:"enableEcsManagedTags,omitempty" tf:"enable_ecs_managed_tags,omitempty"`

	// Specifies whether to enable Amazon ECS Exec for the tasks within the service.
	EnableExecuteCommand *bool `json:"enableExecuteCommand,omitempty" tf:"enable_execute_command,omitempty"`

	// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
	ForceNewDeployment *bool `json:"forceNewDeployment,omitempty" tf:"force_new_deployment,omitempty"`

	// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
	HealthCheckGracePeriodSeconds *float64 `json:"healthCheckGracePeriodSeconds,omitempty" tf:"health_check_grace_period_seconds,omitempty"`

	// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
	IAMRole *string `json:"iamRole,omitempty" tf:"iam_role,omitempty"`

	// ARN that identifies the service.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
	LaunchType *string `json:"launchType,omitempty" tf:"launch_type,omitempty"`

	// Configuration block for load balancers. See below.
	LoadBalancer []LoadBalancerObservation `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
	NetworkConfiguration []NetworkConfigurationObservation `json:"networkConfiguration,omitempty" tf:"network_configuration,omitempty"`

	// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
	OrderedPlacementStrategy []OrderedPlacementStrategyObservation `json:"orderedPlacementStrategy,omitempty" tf:"ordered_placement_strategy,omitempty"`

	// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
	PlacementConstraints []PlacementConstraintsObservation `json:"placementConstraints,omitempty" tf:"placement_constraints,omitempty"`

	// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
	PlatformVersion *string `json:"platformVersion,omitempty" tf:"platform_version,omitempty"`

	// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
	PropagateTags *string `json:"propagateTags,omitempty" tf:"propagate_tags,omitempty"`

	// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
	SchedulingStrategy *string `json:"schedulingStrategy,omitempty" tf:"scheduling_strategy,omitempty"`

	// The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
	ServiceConnectConfiguration []ServiceConnectConfigurationObservation `json:"serviceConnectConfiguration,omitempty" tf:"service_connect_configuration,omitempty"`

	// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
	ServiceRegistries []ServiceRegistriesObservation `json:"serviceRegistries,omitempty" tf:"service_registries,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	// +mapType=granular
	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
	TaskDefinition *string `json:"taskDefinition,omitempty" tf:"task_definition,omitempty"`

	// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
	// +mapType=granular
	Triggers map[string]*string `json:"triggers,omitempty" tf:"triggers,omitempty"`

	// Default false.
	WaitForSteadyState *bool `json:"waitForSteadyState,omitempty" tf:"wait_for_steady_state,omitempty"`
}

type ServiceParameters struct {

	// Information about the CloudWatch alarms. See below.
	// +kubebuilder:validation:Optional
	Alarms []AlarmsParameters `json:"alarms,omitempty" tf:"alarms,omitempty"`

	// Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below. Conflicts with launch_type.
	// +kubebuilder:validation:Optional
	CapacityProviderStrategy []CapacityProviderStrategyParameters `json:"capacityProviderStrategy,omitempty" tf:"capacity_provider_strategy,omitempty"`

	// Name of an ECS cluster.
	// +crossplane:generate:reference:type=Cluster
	// +kubebuilder:validation:Optional
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Reference to a Cluster to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.Reference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.Selector `json:"clusterSelector,omitempty" tf:"-"`

	// Configuration block for deployment circuit breaker. See below.
	// +kubebuilder:validation:Optional
	DeploymentCircuitBreaker []DeploymentCircuitBreakerParameters `json:"deploymentCircuitBreaker,omitempty" tf:"deployment_circuit_breaker,omitempty"`

	// Configuration block for deployment controller configuration. See below.
	// +kubebuilder:validation:Optional
	DeploymentController []DeploymentControllerParameters `json:"deploymentController,omitempty" tf:"deployment_controller,omitempty"`

	// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
	// +kubebuilder:validation:Optional
	DeploymentMaximumPercent *float64 `json:"deploymentMaximumPercent,omitempty" tf:"deployment_maximum_percent,omitempty"`

	// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
	// +kubebuilder:validation:Optional
	DeploymentMinimumHealthyPercent *float64 `json:"deploymentMinimumHealthyPercent,omitempty" tf:"deployment_minimum_healthy_percent,omitempty"`

	// Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
	// +kubebuilder:validation:Optional
	DesiredCount *float64 `json:"desiredCount,omitempty" tf:"desired_count,omitempty"`

	// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
	// +kubebuilder:validation:Optional
	EnableEcsManagedTags *bool `json:"enableEcsManagedTags,omitempty" tf:"enable_ecs_managed_tags,omitempty"`

	// Specifies whether to enable Amazon ECS Exec for the tasks within the service.
	// +kubebuilder:validation:Optional
	EnableExecuteCommand *bool `json:"enableExecuteCommand,omitempty" tf:"enable_execute_command,omitempty"`

	// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
	// +kubebuilder:validation:Optional
	ForceNewDeployment *bool `json:"forceNewDeployment,omitempty" tf:"force_new_deployment,omitempty"`

	// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
	// +kubebuilder:validation:Optional
	HealthCheckGracePeriodSeconds *float64 `json:"healthCheckGracePeriodSeconds,omitempty" tf:"health_check_grace_period_seconds,omitempty"`

	// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	IAMRole *string `json:"iamRole,omitempty" tf:"iam_role,omitempty"`

	// Reference to a Role in iam to populate iamRole.
	// +kubebuilder:validation:Optional
	IAMRoleRef *v1.Reference `json:"iamRoleRef,omitempty" tf:"-"`

	// Selector for a Role in iam to populate iamRole.
	// +kubebuilder:validation:Optional
	IAMRoleSelector *v1.Selector `json:"iamRoleSelector,omitempty" tf:"-"`

	// Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2. Conflicts with capacity_provider_strategy.
	// +kubebuilder:validation:Optional
	LaunchType *string `json:"launchType,omitempty" tf:"launch_type,omitempty"`

	// Configuration block for load balancers. See below.
	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
	// +kubebuilder:validation:Optional
	NetworkConfiguration []NetworkConfigurationParameters `json:"networkConfiguration,omitempty" tf:"network_configuration,omitempty"`

	// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
	// +kubebuilder:validation:Optional
	OrderedPlacementStrategy []OrderedPlacementStrategyParameters `json:"orderedPlacementStrategy,omitempty" tf:"ordered_placement_strategy,omitempty"`

	// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
	// +kubebuilder:validation:Optional
	PlacementConstraints []PlacementConstraintsParameters `json:"placementConstraints,omitempty" tf:"placement_constraints,omitempty"`

	// Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
	// +kubebuilder:validation:Optional
	PlatformVersion *string `json:"platformVersion,omitempty" tf:"platform_version,omitempty"`

	// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
	// +kubebuilder:validation:Optional
	PropagateTags *string `json:"propagateTags,omitempty" tf:"propagate_tags,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
	// +kubebuilder:validation:Optional
	SchedulingStrategy *string `json:"schedulingStrategy,omitempty" tf:"scheduling_strategy,omitempty"`

	// The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
	// +kubebuilder:validation:Optional
	ServiceConnectConfiguration []ServiceConnectConfigurationParameters `json:"serviceConnectConfiguration,omitempty" tf:"service_connect_configuration,omitempty"`

	// Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
	// +kubebuilder:validation:Optional
	ServiceRegistries []ServiceRegistriesParameters `json:"serviceRegistries,omitempty" tf:"service_registries,omitempty"`

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
	// +crossplane:generate:reference:type=TaskDefinition
	// +kubebuilder:validation:Optional
	TaskDefinition *string `json:"taskDefinition,omitempty" tf:"task_definition,omitempty"`

	// Reference to a TaskDefinition to populate taskDefinition.
	// +kubebuilder:validation:Optional
	TaskDefinitionRef *v1.Reference `json:"taskDefinitionRef,omitempty" tf:"-"`

	// Selector for a TaskDefinition to populate taskDefinition.
	// +kubebuilder:validation:Optional
	TaskDefinitionSelector *v1.Selector `json:"taskDefinitionSelector,omitempty" tf:"-"`

	// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with plantimestamp(). See example above.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Triggers map[string]*string `json:"triggers,omitempty" tf:"triggers,omitempty"`

	// Default false.
	// +kubebuilder:validation:Optional
	WaitForSteadyState *bool `json:"waitForSteadyState,omitempty" tf:"wait_for_steady_state,omitempty"`
}

type ServiceRegistriesInitParameters struct {

	// Container name value, already specified in the task definition, to be used for your service discovery service.
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// Port value, already specified in the task definition, to be used for your service discovery service.
	ContainerPort *float64 `json:"containerPort,omitempty" tf:"container_port,omitempty"`

	// Port value used if your Service Discovery service specified an SRV record.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
	RegistryArn *string `json:"registryArn,omitempty" tf:"registry_arn,omitempty"`
}

type ServiceRegistriesObservation struct {

	// Container name value, already specified in the task definition, to be used for your service discovery service.
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// Port value, already specified in the task definition, to be used for your service discovery service.
	ContainerPort *float64 `json:"containerPort,omitempty" tf:"container_port,omitempty"`

	// Port value used if your Service Discovery service specified an SRV record.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
	RegistryArn *string `json:"registryArn,omitempty" tf:"registry_arn,omitempty"`
}

type ServiceRegistriesParameters struct {

	// Container name value, already specified in the task definition, to be used for your service discovery service.
	// +kubebuilder:validation:Optional
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// Port value, already specified in the task definition, to be used for your service discovery service.
	// +kubebuilder:validation:Optional
	ContainerPort *float64 `json:"containerPort,omitempty" tf:"container_port,omitempty"`

	// Port value used if your Service Discovery service specified an SRV record.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
	// +kubebuilder:validation:Optional
	RegistryArn *string `json:"registryArn" tf:"registry_arn,omitempty"`
}

type TLSInitParameters struct {

	// The details of the certificate authority which will issue the certificate.
	IssuerCertAuthority []IssuerCertAuthorityInitParameters `json:"issuerCertAuthority,omitempty" tf:"issuer_cert_authority,omitempty"`

	// The KMS key used to encrypt the private key in Secrets Manager.
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The ARN of the IAM Role that's associated with the Service Connect TLS.
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`
}

type TLSObservation struct {

	// The details of the certificate authority which will issue the certificate.
	IssuerCertAuthority []IssuerCertAuthorityObservation `json:"issuerCertAuthority,omitempty" tf:"issuer_cert_authority,omitempty"`

	// The KMS key used to encrypt the private key in Secrets Manager.
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The ARN of the IAM Role that's associated with the Service Connect TLS.
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`
}

type TLSParameters struct {

	// The details of the certificate authority which will issue the certificate.
	// +kubebuilder:validation:Optional
	IssuerCertAuthority []IssuerCertAuthorityParameters `json:"issuerCertAuthority" tf:"issuer_cert_authority,omitempty"`

	// The KMS key used to encrypt the private key in Secrets Manager.
	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The ARN of the IAM Role that's associated with the Service Connect TLS.
	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`
}

type TimeoutInitParameters struct {

	// The amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" tf:"idle_timeout_seconds,omitempty"`

	// The amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
	PerRequestTimeoutSeconds *float64 `json:"perRequestTimeoutSeconds,omitempty" tf:"per_request_timeout_seconds,omitempty"`
}

type TimeoutObservation struct {

	// The amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" tf:"idle_timeout_seconds,omitempty"`

	// The amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
	PerRequestTimeoutSeconds *float64 `json:"perRequestTimeoutSeconds,omitempty" tf:"per_request_timeout_seconds,omitempty"`
}

type TimeoutParameters struct {

	// The amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
	// +kubebuilder:validation:Optional
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" tf:"idle_timeout_seconds,omitempty"`

	// The amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
	// +kubebuilder:validation:Optional
	PerRequestTimeoutSeconds *float64 `json:"perRequestTimeoutSeconds,omitempty" tf:"per_request_timeout_seconds,omitempty"`
}

// ServiceSpec defines the desired state of Service
type ServiceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServiceInitParameters `json:"initProvider,omitempty"`
}

// ServiceStatus defines the observed state of Service.
type ServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Service is the Schema for the Services API. Provides an ECS service.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Service struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServiceSpec   `json:"spec"`
	Status            ServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceList contains a list of Services
type ServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Service `json:"items"`
}

// Repository type metadata.
var (
	Service_Kind             = "Service"
	Service_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Service_Kind}.String()
	Service_KindAPIVersion   = Service_Kind + "." + CRDGroupVersion.String()
	Service_GroupVersionKind = CRDGroupVersion.WithKind(Service_Kind)
)

func init() {
	SchemeBuilder.Register(&Service{}, &ServiceList{})
}

//go:build !ignore_autogenerated

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Certificate) DeepCopyInto(out *Certificate) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Certificate.
func (in *Certificate) DeepCopy() *Certificate {
	if in == nil {
		return nil
	}
	out := new(Certificate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Certificate) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateInitParameters) DeepCopyInto(out *CertificateInitParameters) {
	*out = *in
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateInitParameters.
func (in *CertificateInitParameters) DeepCopy() *CertificateInitParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateList) DeepCopyInto(out *CertificateList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Certificate, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateList.
func (in *CertificateList) DeepCopy() *CertificateList {
	if in == nil {
		return nil
	}
	out := new(CertificateList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CertificateList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateObservation) DeepCopyInto(out *CertificateObservation) {
	*out = *in
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateObservation.
func (in *CertificateObservation) DeepCopy() *CertificateObservation {
	if in == nil {
		return nil
	}
	out := new(CertificateObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateParameters) DeepCopyInto(out *CertificateParameters) {
	*out = *in
	if in.CertificatePemSecretRef != nil {
		in, out := &in.CertificatePemSecretRef, &out.CertificatePemSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.CertificateWalletSecretRef != nil {
		in, out := &in.CertificateWalletSecretRef, &out.CertificateWalletSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateParameters.
func (in *CertificateParameters) DeepCopy() *CertificateParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateSpec) DeepCopyInto(out *CertificateSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateSpec.
func (in *CertificateSpec) DeepCopy() *CertificateSpec {
	if in == nil {
		return nil
	}
	out := new(CertificateSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateStatus) DeepCopyInto(out *CertificateStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateStatus.
func (in *CertificateStatus) DeepCopy() *CertificateStatus {
	if in == nil {
		return nil
	}
	out := new(CertificateStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchSettingsInitParameters) DeepCopyInto(out *ElasticsearchSettingsInitParameters) {
	*out = *in
	if in.EndpointURI != nil {
		in, out := &in.EndpointURI, &out.EndpointURI
		*out = new(string)
		**out = **in
	}
	if in.ErrorRetryDuration != nil {
		in, out := &in.ErrorRetryDuration, &out.ErrorRetryDuration
		*out = new(int64)
		**out = **in
	}
	if in.FullLoadErrorPercentage != nil {
		in, out := &in.FullLoadErrorPercentage, &out.FullLoadErrorPercentage
		*out = new(int64)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchSettingsInitParameters.
func (in *ElasticsearchSettingsInitParameters) DeepCopy() *ElasticsearchSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchSettingsObservation) DeepCopyInto(out *ElasticsearchSettingsObservation) {
	*out = *in
	if in.EndpointURI != nil {
		in, out := &in.EndpointURI, &out.EndpointURI
		*out = new(string)
		**out = **in
	}
	if in.ErrorRetryDuration != nil {
		in, out := &in.ErrorRetryDuration, &out.ErrorRetryDuration
		*out = new(int64)
		**out = **in
	}
	if in.FullLoadErrorPercentage != nil {
		in, out := &in.FullLoadErrorPercentage, &out.FullLoadErrorPercentage
		*out = new(int64)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchSettingsObservation.
func (in *ElasticsearchSettingsObservation) DeepCopy() *ElasticsearchSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchSettingsParameters) DeepCopyInto(out *ElasticsearchSettingsParameters) {
	*out = *in
	if in.EndpointURI != nil {
		in, out := &in.EndpointURI, &out.EndpointURI
		*out = new(string)
		**out = **in
	}
	if in.ErrorRetryDuration != nil {
		in, out := &in.ErrorRetryDuration, &out.ErrorRetryDuration
		*out = new(int64)
		**out = **in
	}
	if in.FullLoadErrorPercentage != nil {
		in, out := &in.FullLoadErrorPercentage, &out.FullLoadErrorPercentage
		*out = new(int64)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchSettingsParameters.
func (in *ElasticsearchSettingsParameters) DeepCopy() *ElasticsearchSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Endpoint) DeepCopyInto(out *Endpoint) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Endpoint.
func (in *Endpoint) DeepCopy() *Endpoint {
	if in == nil {
		return nil
	}
	out := new(Endpoint)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Endpoint) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointInitParameters) DeepCopyInto(out *EndpointInitParameters) {
	*out = *in
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.DatabaseName != nil {
		in, out := &in.DatabaseName, &out.DatabaseName
		*out = new(string)
		**out = **in
	}
	if in.ElasticsearchSettings != nil {
		in, out := &in.ElasticsearchSettings, &out.ElasticsearchSettings
		*out = make([]ElasticsearchSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.EngineName != nil {
		in, out := &in.EngineName, &out.EngineName
		*out = new(string)
		**out = **in
	}
	if in.ExtraConnectionAttributes != nil {
		in, out := &in.ExtraConnectionAttributes, &out.ExtraConnectionAttributes
		*out = new(string)
		**out = **in
	}
	if in.KafkaSettings != nil {
		in, out := &in.KafkaSettings, &out.KafkaSettings
		*out = make([]KafkaSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.KinesisSettings != nil {
		in, out := &in.KinesisSettings, &out.KinesisSettings
		*out = make([]KinesisSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MongodbSettings != nil {
		in, out := &in.MongodbSettings, &out.MongodbSettings
		*out = make([]MongodbSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.RedisSettings != nil {
		in, out := &in.RedisSettings, &out.RedisSettings
		*out = make([]RedisSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedshiftSettings != nil {
		in, out := &in.RedshiftSettings, &out.RedshiftSettings
		*out = make([]RedshiftSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.S3Settings != nil {
		in, out := &in.S3Settings, &out.S3Settings
		*out = make([]S3SettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.SecretsManagerArn != nil {
		in, out := &in.SecretsManagerArn, &out.SecretsManagerArn
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointInitParameters.
func (in *EndpointInitParameters) DeepCopy() *EndpointInitParameters {
	if in == nil {
		return nil
	}
	out := new(EndpointInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointList) DeepCopyInto(out *EndpointList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Endpoint, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointList.
func (in *EndpointList) DeepCopy() *EndpointList {
	if in == nil {
		return nil
	}
	out := new(EndpointList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *EndpointList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointObservation) DeepCopyInto(out *EndpointObservation) {
	*out = *in
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.DatabaseName != nil {
		in, out := &in.DatabaseName, &out.DatabaseName
		*out = new(string)
		**out = **in
	}
	if in.ElasticsearchSettings != nil {
		in, out := &in.ElasticsearchSettings, &out.ElasticsearchSettings
		*out = make([]ElasticsearchSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EndpointArn != nil {
		in, out := &in.EndpointArn, &out.EndpointArn
		*out = new(string)
		**out = **in
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.EngineName != nil {
		in, out := &in.EngineName, &out.EngineName
		*out = new(string)
		**out = **in
	}
	if in.ExtraConnectionAttributes != nil {
		in, out := &in.ExtraConnectionAttributes, &out.ExtraConnectionAttributes
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.KafkaSettings != nil {
		in, out := &in.KafkaSettings, &out.KafkaSettings
		*out = make([]KafkaSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.KinesisSettings != nil {
		in, out := &in.KinesisSettings, &out.KinesisSettings
		*out = make([]KinesisSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MongodbSettings != nil {
		in, out := &in.MongodbSettings, &out.MongodbSettings
		*out = make([]MongodbSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.RedisSettings != nil {
		in, out := &in.RedisSettings, &out.RedisSettings
		*out = make([]RedisSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedshiftSettings != nil {
		in, out := &in.RedshiftSettings, &out.RedshiftSettings
		*out = make([]RedshiftSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.S3Settings != nil {
		in, out := &in.S3Settings, &out.S3Settings
		*out = make([]S3SettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.SecretsManagerAccessRoleArn != nil {
		in, out := &in.SecretsManagerAccessRoleArn, &out.SecretsManagerAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.SecretsManagerArn != nil {
		in, out := &in.SecretsManagerArn, &out.SecretsManagerArn
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRole != nil {
		in, out := &in.ServiceAccessRole, &out.ServiceAccessRole
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointObservation.
func (in *EndpointObservation) DeepCopy() *EndpointObservation {
	if in == nil {
		return nil
	}
	out := new(EndpointObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointParameters) DeepCopyInto(out *EndpointParameters) {
	*out = *in
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.DatabaseName != nil {
		in, out := &in.DatabaseName, &out.DatabaseName
		*out = new(string)
		**out = **in
	}
	if in.ElasticsearchSettings != nil {
		in, out := &in.ElasticsearchSettings, &out.ElasticsearchSettings
		*out = make([]ElasticsearchSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.EngineName != nil {
		in, out := &in.EngineName, &out.EngineName
		*out = new(string)
		**out = **in
	}
	if in.ExtraConnectionAttributes != nil {
		in, out := &in.ExtraConnectionAttributes, &out.ExtraConnectionAttributes
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArnRef != nil {
		in, out := &in.KMSKeyArnRef, &out.KMSKeyArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.KMSKeyArnSelector != nil {
		in, out := &in.KMSKeyArnSelector, &out.KMSKeyArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.KafkaSettings != nil {
		in, out := &in.KafkaSettings, &out.KafkaSettings
		*out = make([]KafkaSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.KinesisSettings != nil {
		in, out := &in.KinesisSettings, &out.KinesisSettings
		*out = make([]KinesisSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MongodbSettings != nil {
		in, out := &in.MongodbSettings, &out.MongodbSettings
		*out = make([]MongodbSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.RedisSettings != nil {
		in, out := &in.RedisSettings, &out.RedisSettings
		*out = make([]RedisSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RedshiftSettings != nil {
		in, out := &in.RedshiftSettings, &out.RedshiftSettings
		*out = make([]RedshiftSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.S3Settings != nil {
		in, out := &in.S3Settings, &out.S3Settings
		*out = make([]S3SettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.SecretsManagerAccessRoleArn != nil {
		in, out := &in.SecretsManagerAccessRoleArn, &out.SecretsManagerAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.SecretsManagerAccessRoleArnRef != nil {
		in, out := &in.SecretsManagerAccessRoleArnRef, &out.SecretsManagerAccessRoleArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretsManagerAccessRoleArnSelector != nil {
		in, out := &in.SecretsManagerAccessRoleArnSelector, &out.SecretsManagerAccessRoleArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretsManagerArn != nil {
		in, out := &in.SecretsManagerArn, &out.SecretsManagerArn
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRole != nil {
		in, out := &in.ServiceAccessRole, &out.ServiceAccessRole
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleRef != nil {
		in, out := &in.ServiceAccessRoleRef, &out.ServiceAccessRoleRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccessRoleSelector != nil {
		in, out := &in.ServiceAccessRoleSelector, &out.ServiceAccessRoleSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointParameters.
func (in *EndpointParameters) DeepCopy() *EndpointParameters {
	if in == nil {
		return nil
	}
	out := new(EndpointParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointSpec) DeepCopyInto(out *EndpointSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointSpec.
func (in *EndpointSpec) DeepCopy() *EndpointSpec {
	if in == nil {
		return nil
	}
	out := new(EndpointSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointStatus) DeepCopyInto(out *EndpointStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointStatus.
func (in *EndpointStatus) DeepCopy() *EndpointStatus {
	if in == nil {
		return nil
	}
	out := new(EndpointStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscription) DeepCopyInto(out *EventSubscription) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscription.
func (in *EventSubscription) DeepCopy() *EventSubscription {
	if in == nil {
		return nil
	}
	out := new(EventSubscription)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *EventSubscription) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionInitParameters) DeepCopyInto(out *EventSubscriptionInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EventCategories != nil {
		in, out := &in.EventCategories, &out.EventCategories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SourceIds != nil {
		in, out := &in.SourceIds, &out.SourceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionInitParameters.
func (in *EventSubscriptionInitParameters) DeepCopy() *EventSubscriptionInitParameters {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionList) DeepCopyInto(out *EventSubscriptionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]EventSubscription, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionList.
func (in *EventSubscriptionList) DeepCopy() *EventSubscriptionList {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *EventSubscriptionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionObservation) DeepCopyInto(out *EventSubscriptionObservation) {
	*out = *in
	if in.Arn != nil {
		in, out := &in.Arn, &out.Arn
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EventCategories != nil {
		in, out := &in.EventCategories, &out.EventCategories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.SnsTopicArn != nil {
		in, out := &in.SnsTopicArn, &out.SnsTopicArn
		*out = new(string)
		**out = **in
	}
	if in.SourceIds != nil {
		in, out := &in.SourceIds, &out.SourceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionObservation.
func (in *EventSubscriptionObservation) DeepCopy() *EventSubscriptionObservation {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionParameters) DeepCopyInto(out *EventSubscriptionParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EventCategories != nil {
		in, out := &in.EventCategories, &out.EventCategories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SnsTopicArn != nil {
		in, out := &in.SnsTopicArn, &out.SnsTopicArn
		*out = new(string)
		**out = **in
	}
	if in.SnsTopicArnRef != nil {
		in, out := &in.SnsTopicArnRef, &out.SnsTopicArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.SnsTopicArnSelector != nil {
		in, out := &in.SnsTopicArnSelector, &out.SnsTopicArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.SourceIds != nil {
		in, out := &in.SourceIds, &out.SourceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionParameters.
func (in *EventSubscriptionParameters) DeepCopy() *EventSubscriptionParameters {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionSpec) DeepCopyInto(out *EventSubscriptionSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionSpec.
func (in *EventSubscriptionSpec) DeepCopy() *EventSubscriptionSpec {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EventSubscriptionStatus) DeepCopyInto(out *EventSubscriptionStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EventSubscriptionStatus.
func (in *EventSubscriptionStatus) DeepCopy() *EventSubscriptionStatus {
	if in == nil {
		return nil
	}
	out := new(EventSubscriptionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSettingsInitParameters) DeepCopyInto(out *KafkaSettingsInitParameters) {
	*out = *in
	if in.Broker != nil {
		in, out := &in.Broker, &out.Broker
		*out = new(string)
		**out = **in
	}
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.MessageMaxBytes != nil {
		in, out := &in.MessageMaxBytes, &out.MessageMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.NoHexPrefix != nil {
		in, out := &in.NoHexPrefix, &out.NoHexPrefix
		*out = new(bool)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientCertificateArn != nil {
		in, out := &in.SSLClientCertificateArn, &out.SSLClientCertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientKeyArn != nil {
		in, out := &in.SSLClientKeyArn, &out.SSLClientKeyArn
		*out = new(string)
		**out = **in
	}
	if in.SaslUsername != nil {
		in, out := &in.SaslUsername, &out.SaslUsername
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSettingsInitParameters.
func (in *KafkaSettingsInitParameters) DeepCopy() *KafkaSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSettingsObservation) DeepCopyInto(out *KafkaSettingsObservation) {
	*out = *in
	if in.Broker != nil {
		in, out := &in.Broker, &out.Broker
		*out = new(string)
		**out = **in
	}
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.MessageMaxBytes != nil {
		in, out := &in.MessageMaxBytes, &out.MessageMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.NoHexPrefix != nil {
		in, out := &in.NoHexPrefix, &out.NoHexPrefix
		*out = new(bool)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientCertificateArn != nil {
		in, out := &in.SSLClientCertificateArn, &out.SSLClientCertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientKeyArn != nil {
		in, out := &in.SSLClientKeyArn, &out.SSLClientKeyArn
		*out = new(string)
		**out = **in
	}
	if in.SaslUsername != nil {
		in, out := &in.SaslUsername, &out.SaslUsername
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSettingsObservation.
func (in *KafkaSettingsObservation) DeepCopy() *KafkaSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSettingsParameters) DeepCopyInto(out *KafkaSettingsParameters) {
	*out = *in
	if in.Broker != nil {
		in, out := &in.Broker, &out.Broker
		*out = new(string)
		**out = **in
	}
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.MessageMaxBytes != nil {
		in, out := &in.MessageMaxBytes, &out.MessageMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.NoHexPrefix != nil {
		in, out := &in.NoHexPrefix, &out.NoHexPrefix
		*out = new(bool)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientCertificateArn != nil {
		in, out := &in.SSLClientCertificateArn, &out.SSLClientCertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientKeyArn != nil {
		in, out := &in.SSLClientKeyArn, &out.SSLClientKeyArn
		*out = new(string)
		**out = **in
	}
	if in.SSLClientKeyPasswordSecretRef != nil {
		in, out := &in.SSLClientKeyPasswordSecretRef, &out.SSLClientKeyPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SaslPasswordSecretRef != nil {
		in, out := &in.SaslPasswordSecretRef, &out.SaslPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SaslUsername != nil {
		in, out := &in.SaslUsername, &out.SaslUsername
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSettingsParameters.
func (in *KafkaSettingsParameters) DeepCopy() *KafkaSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KinesisSettingsInitParameters) DeepCopyInto(out *KinesisSettingsInitParameters) {
	*out = *in
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.StreamArn != nil {
		in, out := &in.StreamArn, &out.StreamArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KinesisSettingsInitParameters.
func (in *KinesisSettingsInitParameters) DeepCopy() *KinesisSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(KinesisSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KinesisSettingsObservation) DeepCopyInto(out *KinesisSettingsObservation) {
	*out = *in
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.StreamArn != nil {
		in, out := &in.StreamArn, &out.StreamArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KinesisSettingsObservation.
func (in *KinesisSettingsObservation) DeepCopy() *KinesisSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(KinesisSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KinesisSettingsParameters) DeepCopyInto(out *KinesisSettingsParameters) {
	*out = *in
	if in.IncludeControlDetails != nil {
		in, out := &in.IncludeControlDetails, &out.IncludeControlDetails
		*out = new(bool)
		**out = **in
	}
	if in.IncludeNullAndEmpty != nil {
		in, out := &in.IncludeNullAndEmpty, &out.IncludeNullAndEmpty
		*out = new(bool)
		**out = **in
	}
	if in.IncludePartitionValue != nil {
		in, out := &in.IncludePartitionValue, &out.IncludePartitionValue
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTableAlterOperations != nil {
		in, out := &in.IncludeTableAlterOperations, &out.IncludeTableAlterOperations
		*out = new(bool)
		**out = **in
	}
	if in.IncludeTransactionDetails != nil {
		in, out := &in.IncludeTransactionDetails, &out.IncludeTransactionDetails
		*out = new(bool)
		**out = **in
	}
	if in.MessageFormat != nil {
		in, out := &in.MessageFormat, &out.MessageFormat
		*out = new(string)
		**out = **in
	}
	if in.PartitionIncludeSchemaTable != nil {
		in, out := &in.PartitionIncludeSchemaTable, &out.PartitionIncludeSchemaTable
		*out = new(bool)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.StreamArn != nil {
		in, out := &in.StreamArn, &out.StreamArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KinesisSettingsParameters.
func (in *KinesisSettingsParameters) DeepCopy() *KinesisSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(KinesisSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbSettingsInitParameters) DeepCopyInto(out *MongodbSettingsInitParameters) {
	*out = *in
	if in.AuthMechanism != nil {
		in, out := &in.AuthMechanism, &out.AuthMechanism
		*out = new(string)
		**out = **in
	}
	if in.AuthSource != nil {
		in, out := &in.AuthSource, &out.AuthSource
		*out = new(string)
		**out = **in
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.DocsToInvestigate != nil {
		in, out := &in.DocsToInvestigate, &out.DocsToInvestigate
		*out = new(string)
		**out = **in
	}
	if in.ExtractDocID != nil {
		in, out := &in.ExtractDocID, &out.ExtractDocID
		*out = new(string)
		**out = **in
	}
	if in.NestingLevel != nil {
		in, out := &in.NestingLevel, &out.NestingLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbSettingsInitParameters.
func (in *MongodbSettingsInitParameters) DeepCopy() *MongodbSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbSettingsObservation) DeepCopyInto(out *MongodbSettingsObservation) {
	*out = *in
	if in.AuthMechanism != nil {
		in, out := &in.AuthMechanism, &out.AuthMechanism
		*out = new(string)
		**out = **in
	}
	if in.AuthSource != nil {
		in, out := &in.AuthSource, &out.AuthSource
		*out = new(string)
		**out = **in
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.DocsToInvestigate != nil {
		in, out := &in.DocsToInvestigate, &out.DocsToInvestigate
		*out = new(string)
		**out = **in
	}
	if in.ExtractDocID != nil {
		in, out := &in.ExtractDocID, &out.ExtractDocID
		*out = new(string)
		**out = **in
	}
	if in.NestingLevel != nil {
		in, out := &in.NestingLevel, &out.NestingLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbSettingsObservation.
func (in *MongodbSettingsObservation) DeepCopy() *MongodbSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbSettingsParameters) DeepCopyInto(out *MongodbSettingsParameters) {
	*out = *in
	if in.AuthMechanism != nil {
		in, out := &in.AuthMechanism, &out.AuthMechanism
		*out = new(string)
		**out = **in
	}
	if in.AuthSource != nil {
		in, out := &in.AuthSource, &out.AuthSource
		*out = new(string)
		**out = **in
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.DocsToInvestigate != nil {
		in, out := &in.DocsToInvestigate, &out.DocsToInvestigate
		*out = new(string)
		**out = **in
	}
	if in.ExtractDocID != nil {
		in, out := &in.ExtractDocID, &out.ExtractDocID
		*out = new(string)
		**out = **in
	}
	if in.NestingLevel != nil {
		in, out := &in.NestingLevel, &out.NestingLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbSettingsParameters.
func (in *MongodbSettingsParameters) DeepCopy() *MongodbSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSettingsInitParameters) DeepCopyInto(out *RedisSettingsInitParameters) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.AuthUserName != nil {
		in, out := &in.AuthUserName, &out.AuthUserName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLSecurityProtocol != nil {
		in, out := &in.SSLSecurityProtocol, &out.SSLSecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSettingsInitParameters.
func (in *RedisSettingsInitParameters) DeepCopy() *RedisSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSettingsObservation) DeepCopyInto(out *RedisSettingsObservation) {
	*out = *in
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.AuthUserName != nil {
		in, out := &in.AuthUserName, &out.AuthUserName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLSecurityProtocol != nil {
		in, out := &in.SSLSecurityProtocol, &out.SSLSecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSettingsObservation.
func (in *RedisSettingsObservation) DeepCopy() *RedisSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(RedisSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSettingsParameters) DeepCopyInto(out *RedisSettingsParameters) {
	*out = *in
	if in.AuthPasswordSecretRef != nil {
		in, out := &in.AuthPasswordSecretRef, &out.AuthPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.AuthType != nil {
		in, out := &in.AuthType, &out.AuthType
		*out = new(string)
		**out = **in
	}
	if in.AuthUserName != nil {
		in, out := &in.AuthUserName, &out.AuthUserName
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.SSLCACertificateArn != nil {
		in, out := &in.SSLCACertificateArn, &out.SSLCACertificateArn
		*out = new(string)
		**out = **in
	}
	if in.SSLSecurityProtocol != nil {
		in, out := &in.SSLSecurityProtocol, &out.SSLSecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.ServerName != nil {
		in, out := &in.ServerName, &out.ServerName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSettingsParameters.
func (in *RedisSettingsParameters) DeepCopy() *RedisSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(RedisSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftSettingsInitParameters) DeepCopyInto(out *RedshiftSettingsInitParameters) {
	*out = *in
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftSettingsInitParameters.
func (in *RedshiftSettingsInitParameters) DeepCopy() *RedshiftSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedshiftSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftSettingsObservation) DeepCopyInto(out *RedshiftSettingsObservation) {
	*out = *in
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftSettingsObservation.
func (in *RedshiftSettingsObservation) DeepCopy() *RedshiftSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(RedshiftSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedshiftSettingsParameters) DeepCopyInto(out *RedshiftSettingsParameters) {
	*out = *in
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedshiftSettingsParameters.
func (in *RedshiftSettingsParameters) DeepCopy() *RedshiftSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(RedshiftSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstance) DeepCopyInto(out *ReplicationInstance) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstance.
func (in *ReplicationInstance) DeepCopy() *ReplicationInstance {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstance)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationInstance) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceInitParameters) DeepCopyInto(out *ReplicationInstanceInitParameters) {
	*out = *in
	if in.AllocatedStorage != nil {
		in, out := &in.AllocatedStorage, &out.AllocatedStorage
		*out = new(int64)
		**out = **in
	}
	if in.AllowMajorVersionUpgrade != nil {
		in, out := &in.AllowMajorVersionUpgrade, &out.AllowMajorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.ApplyImmediately != nil {
		in, out := &in.ApplyImmediately, &out.ApplyImmediately
		*out = new(bool)
		**out = **in
	}
	if in.AutoMinorVersionUpgrade != nil {
		in, out := &in.AutoMinorVersionUpgrade, &out.AutoMinorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.NetworkType != nil {
		in, out := &in.NetworkType, &out.NetworkType
		*out = new(string)
		**out = **in
	}
	if in.PreferredMaintenanceWindow != nil {
		in, out := &in.PreferredMaintenanceWindow, &out.PreferredMaintenanceWindow
		*out = new(string)
		**out = **in
	}
	if in.PubliclyAccessible != nil {
		in, out := &in.PubliclyAccessible, &out.PubliclyAccessible
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationInstanceClass != nil {
		in, out := &in.ReplicationInstanceClass, &out.ReplicationInstanceClass
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceInitParameters.
func (in *ReplicationInstanceInitParameters) DeepCopy() *ReplicationInstanceInitParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceList) DeepCopyInto(out *ReplicationInstanceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ReplicationInstance, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceList.
func (in *ReplicationInstanceList) DeepCopy() *ReplicationInstanceList {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationInstanceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceObservation) DeepCopyInto(out *ReplicationInstanceObservation) {
	*out = *in
	if in.AllocatedStorage != nil {
		in, out := &in.AllocatedStorage, &out.AllocatedStorage
		*out = new(int64)
		**out = **in
	}
	if in.AllowMajorVersionUpgrade != nil {
		in, out := &in.AllowMajorVersionUpgrade, &out.AllowMajorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.ApplyImmediately != nil {
		in, out := &in.ApplyImmediately, &out.ApplyImmediately
		*out = new(bool)
		**out = **in
	}
	if in.AutoMinorVersionUpgrade != nil {
		in, out := &in.AutoMinorVersionUpgrade, &out.AutoMinorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.NetworkType != nil {
		in, out := &in.NetworkType, &out.NetworkType
		*out = new(string)
		**out = **in
	}
	if in.PreferredMaintenanceWindow != nil {
		in, out := &in.PreferredMaintenanceWindow, &out.PreferredMaintenanceWindow
		*out = new(string)
		**out = **in
	}
	if in.PubliclyAccessible != nil {
		in, out := &in.PubliclyAccessible, &out.PubliclyAccessible
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationInstanceArn != nil {
		in, out := &in.ReplicationInstanceArn, &out.ReplicationInstanceArn
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstanceClass != nil {
		in, out := &in.ReplicationInstanceClass, &out.ReplicationInstanceClass
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstancePrivateIps != nil {
		in, out := &in.ReplicationInstancePrivateIps, &out.ReplicationInstancePrivateIps
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ReplicationInstancePublicIps != nil {
		in, out := &in.ReplicationInstancePublicIps, &out.ReplicationInstancePublicIps
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ReplicationSubnetGroupID != nil {
		in, out := &in.ReplicationSubnetGroupID, &out.ReplicationSubnetGroupID
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.VPCSecurityGroupIds != nil {
		in, out := &in.VPCSecurityGroupIds, &out.VPCSecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceObservation.
func (in *ReplicationInstanceObservation) DeepCopy() *ReplicationInstanceObservation {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceParameters) DeepCopyInto(out *ReplicationInstanceParameters) {
	*out = *in
	if in.AllocatedStorage != nil {
		in, out := &in.AllocatedStorage, &out.AllocatedStorage
		*out = new(int64)
		**out = **in
	}
	if in.AllowMajorVersionUpgrade != nil {
		in, out := &in.AllowMajorVersionUpgrade, &out.AllowMajorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.ApplyImmediately != nil {
		in, out := &in.ApplyImmediately, &out.ApplyImmediately
		*out = new(bool)
		**out = **in
	}
	if in.AutoMinorVersionUpgrade != nil {
		in, out := &in.AutoMinorVersionUpgrade, &out.AutoMinorVersionUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArnRef != nil {
		in, out := &in.KMSKeyArnRef, &out.KMSKeyArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.KMSKeyArnSelector != nil {
		in, out := &in.KMSKeyArnSelector, &out.KMSKeyArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.NetworkType != nil {
		in, out := &in.NetworkType, &out.NetworkType
		*out = new(string)
		**out = **in
	}
	if in.PreferredMaintenanceWindow != nil {
		in, out := &in.PreferredMaintenanceWindow, &out.PreferredMaintenanceWindow
		*out = new(string)
		**out = **in
	}
	if in.PubliclyAccessible != nil {
		in, out := &in.PubliclyAccessible, &out.PubliclyAccessible
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstanceClass != nil {
		in, out := &in.ReplicationInstanceClass, &out.ReplicationInstanceClass
		*out = new(string)
		**out = **in
	}
	if in.ReplicationSubnetGroupID != nil {
		in, out := &in.ReplicationSubnetGroupID, &out.ReplicationSubnetGroupID
		*out = new(string)
		**out = **in
	}
	if in.ReplicationSubnetGroupIDRef != nil {
		in, out := &in.ReplicationSubnetGroupIDRef, &out.ReplicationSubnetGroupIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ReplicationSubnetGroupIDSelector != nil {
		in, out := &in.ReplicationSubnetGroupIDSelector, &out.ReplicationSubnetGroupIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.VPCSecurityGroupIDRefs != nil {
		in, out := &in.VPCSecurityGroupIDRefs, &out.VPCSecurityGroupIDRefs
		*out = make([]v1.Reference, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VPCSecurityGroupIDSelector != nil {
		in, out := &in.VPCSecurityGroupIDSelector, &out.VPCSecurityGroupIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.VPCSecurityGroupIds != nil {
		in, out := &in.VPCSecurityGroupIds, &out.VPCSecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceParameters.
func (in *ReplicationInstanceParameters) DeepCopy() *ReplicationInstanceParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceSpec) DeepCopyInto(out *ReplicationInstanceSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceSpec.
func (in *ReplicationInstanceSpec) DeepCopy() *ReplicationInstanceSpec {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationInstanceStatus) DeepCopyInto(out *ReplicationInstanceStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationInstanceStatus.
func (in *ReplicationInstanceStatus) DeepCopy() *ReplicationInstanceStatus {
	if in == nil {
		return nil
	}
	out := new(ReplicationInstanceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroup) DeepCopyInto(out *ReplicationSubnetGroup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroup.
func (in *ReplicationSubnetGroup) DeepCopy() *ReplicationSubnetGroup {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationSubnetGroup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupInitParameters) DeepCopyInto(out *ReplicationSubnetGroupInitParameters) {
	*out = *in
	if in.ReplicationSubnetGroupDescription != nil {
		in, out := &in.ReplicationSubnetGroupDescription, &out.ReplicationSubnetGroupDescription
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupInitParameters.
func (in *ReplicationSubnetGroupInitParameters) DeepCopy() *ReplicationSubnetGroupInitParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupList) DeepCopyInto(out *ReplicationSubnetGroupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ReplicationSubnetGroup, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupList.
func (in *ReplicationSubnetGroupList) DeepCopy() *ReplicationSubnetGroupList {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationSubnetGroupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupObservation) DeepCopyInto(out *ReplicationSubnetGroupObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ReplicationSubnetGroupArn != nil {
		in, out := &in.ReplicationSubnetGroupArn, &out.ReplicationSubnetGroupArn
		*out = new(string)
		**out = **in
	}
	if in.ReplicationSubnetGroupDescription != nil {
		in, out := &in.ReplicationSubnetGroupDescription, &out.ReplicationSubnetGroupDescription
		*out = new(string)
		**out = **in
	}
	if in.SubnetIds != nil {
		in, out := &in.SubnetIds, &out.SubnetIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupObservation.
func (in *ReplicationSubnetGroupObservation) DeepCopy() *ReplicationSubnetGroupObservation {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupParameters) DeepCopyInto(out *ReplicationSubnetGroupParameters) {
	*out = *in
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.ReplicationSubnetGroupDescription != nil {
		in, out := &in.ReplicationSubnetGroupDescription, &out.ReplicationSubnetGroupDescription
		*out = new(string)
		**out = **in
	}
	if in.SubnetIDRefs != nil {
		in, out := &in.SubnetIDRefs, &out.SubnetIDRefs
		*out = make([]v1.Reference, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SubnetIDSelector != nil {
		in, out := &in.SubnetIDSelector, &out.SubnetIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.SubnetIds != nil {
		in, out := &in.SubnetIds, &out.SubnetIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupParameters.
func (in *ReplicationSubnetGroupParameters) DeepCopy() *ReplicationSubnetGroupParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupSpec) DeepCopyInto(out *ReplicationSubnetGroupSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupSpec.
func (in *ReplicationSubnetGroupSpec) DeepCopy() *ReplicationSubnetGroupSpec {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationSubnetGroupStatus) DeepCopyInto(out *ReplicationSubnetGroupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationSubnetGroupStatus.
func (in *ReplicationSubnetGroupStatus) DeepCopy() *ReplicationSubnetGroupStatus {
	if in == nil {
		return nil
	}
	out := new(ReplicationSubnetGroupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTask) DeepCopyInto(out *ReplicationTask) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTask.
func (in *ReplicationTask) DeepCopy() *ReplicationTask {
	if in == nil {
		return nil
	}
	out := new(ReplicationTask)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationTask) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskInitParameters) DeepCopyInto(out *ReplicationTaskInitParameters) {
	*out = *in
	if in.CdcStartPosition != nil {
		in, out := &in.CdcStartPosition, &out.CdcStartPosition
		*out = new(string)
		**out = **in
	}
	if in.CdcStartTime != nil {
		in, out := &in.CdcStartTime, &out.CdcStartTime
		*out = new(string)
		**out = **in
	}
	if in.MigrationType != nil {
		in, out := &in.MigrationType, &out.MigrationType
		*out = new(string)
		**out = **in
	}
	if in.ReplicationTaskSettings != nil {
		in, out := &in.ReplicationTaskSettings, &out.ReplicationTaskSettings
		*out = new(string)
		**out = **in
	}
	if in.StartReplicationTask != nil {
		in, out := &in.StartReplicationTask, &out.StartReplicationTask
		*out = new(bool)
		**out = **in
	}
	if in.TableMappings != nil {
		in, out := &in.TableMappings, &out.TableMappings
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskInitParameters.
func (in *ReplicationTaskInitParameters) DeepCopy() *ReplicationTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskList) DeepCopyInto(out *ReplicationTaskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ReplicationTask, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskList.
func (in *ReplicationTaskList) DeepCopy() *ReplicationTaskList {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ReplicationTaskList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskObservation) DeepCopyInto(out *ReplicationTaskObservation) {
	*out = *in
	if in.CdcStartPosition != nil {
		in, out := &in.CdcStartPosition, &out.CdcStartPosition
		*out = new(string)
		**out = **in
	}
	if in.CdcStartTime != nil {
		in, out := &in.CdcStartTime, &out.CdcStartTime
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.MigrationType != nil {
		in, out := &in.MigrationType, &out.MigrationType
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstanceArn != nil {
		in, out := &in.ReplicationInstanceArn, &out.ReplicationInstanceArn
		*out = new(string)
		**out = **in
	}
	if in.ReplicationTaskArn != nil {
		in, out := &in.ReplicationTaskArn, &out.ReplicationTaskArn
		*out = new(string)
		**out = **in
	}
	if in.ReplicationTaskSettings != nil {
		in, out := &in.ReplicationTaskSettings, &out.ReplicationTaskSettings
		*out = new(string)
		**out = **in
	}
	if in.SourceEndpointArn != nil {
		in, out := &in.SourceEndpointArn, &out.SourceEndpointArn
		*out = new(string)
		**out = **in
	}
	if in.StartReplicationTask != nil {
		in, out := &in.StartReplicationTask, &out.StartReplicationTask
		*out = new(bool)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.TableMappings != nil {
		in, out := &in.TableMappings, &out.TableMappings
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TargetEndpointArn != nil {
		in, out := &in.TargetEndpointArn, &out.TargetEndpointArn
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskObservation.
func (in *ReplicationTaskObservation) DeepCopy() *ReplicationTaskObservation {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskParameters) DeepCopyInto(out *ReplicationTaskParameters) {
	*out = *in
	if in.CdcStartPosition != nil {
		in, out := &in.CdcStartPosition, &out.CdcStartPosition
		*out = new(string)
		**out = **in
	}
	if in.CdcStartTime != nil {
		in, out := &in.CdcStartTime, &out.CdcStartTime
		*out = new(string)
		**out = **in
	}
	if in.MigrationType != nil {
		in, out := &in.MigrationType, &out.MigrationType
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstanceArn != nil {
		in, out := &in.ReplicationInstanceArn, &out.ReplicationInstanceArn
		*out = new(string)
		**out = **in
	}
	if in.ReplicationInstanceArnRef != nil {
		in, out := &in.ReplicationInstanceArnRef, &out.ReplicationInstanceArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ReplicationInstanceArnSelector != nil {
		in, out := &in.ReplicationInstanceArnSelector, &out.ReplicationInstanceArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ReplicationTaskSettings != nil {
		in, out := &in.ReplicationTaskSettings, &out.ReplicationTaskSettings
		*out = new(string)
		**out = **in
	}
	if in.SourceEndpointArn != nil {
		in, out := &in.SourceEndpointArn, &out.SourceEndpointArn
		*out = new(string)
		**out = **in
	}
	if in.SourceEndpointArnRef != nil {
		in, out := &in.SourceEndpointArnRef, &out.SourceEndpointArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.SourceEndpointArnSelector != nil {
		in, out := &in.SourceEndpointArnSelector, &out.SourceEndpointArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.StartReplicationTask != nil {
		in, out := &in.StartReplicationTask, &out.StartReplicationTask
		*out = new(bool)
		**out = **in
	}
	if in.TableMappings != nil {
		in, out := &in.TableMappings, &out.TableMappings
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TargetEndpointArn != nil {
		in, out := &in.TargetEndpointArn, &out.TargetEndpointArn
		*out = new(string)
		**out = **in
	}
	if in.TargetEndpointArnRef != nil {
		in, out := &in.TargetEndpointArnRef, &out.TargetEndpointArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.TargetEndpointArnSelector != nil {
		in, out := &in.TargetEndpointArnSelector, &out.TargetEndpointArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskParameters.
func (in *ReplicationTaskParameters) DeepCopy() *ReplicationTaskParameters {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskSpec) DeepCopyInto(out *ReplicationTaskSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskSpec.
func (in *ReplicationTaskSpec) DeepCopy() *ReplicationTaskSpec {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicationTaskStatus) DeepCopyInto(out *ReplicationTaskStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicationTaskStatus.
func (in *ReplicationTaskStatus) DeepCopy() *ReplicationTaskStatus {
	if in == nil {
		return nil
	}
	out := new(ReplicationTaskStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3Endpoint) DeepCopyInto(out *S3Endpoint) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3Endpoint.
func (in *S3Endpoint) DeepCopy() *S3Endpoint {
	if in == nil {
		return nil
	}
	out := new(S3Endpoint)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *S3Endpoint) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointInitParameters) DeepCopyInto(out *S3EndpointInitParameters) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.AddTrailingPaddingCharacter != nil {
		in, out := &in.AddTrailingPaddingCharacter, &out.AddTrailingPaddingCharacter
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionTimezone != nil {
		in, out := &in.DatePartitionTimezone, &out.DatePartitionTimezone
		*out = new(string)
		**out = **in
	}
	if in.DetachTargetOnLobLookupFailureParquet != nil {
		in, out := &in.DetachTargetOnLobLookupFailureParquet, &out.DetachTargetOnLobLookupFailureParquet
		*out = new(bool)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.ExpectedBucketOwner != nil {
		in, out := &in.ExpectedBucketOwner, &out.ExpectedBucketOwner
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointInitParameters.
func (in *S3EndpointInitParameters) DeepCopy() *S3EndpointInitParameters {
	if in == nil {
		return nil
	}
	out := new(S3EndpointInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointList) DeepCopyInto(out *S3EndpointList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]S3Endpoint, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointList.
func (in *S3EndpointList) DeepCopy() *S3EndpointList {
	if in == nil {
		return nil
	}
	out := new(S3EndpointList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *S3EndpointList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointObservation) DeepCopyInto(out *S3EndpointObservation) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.AddTrailingPaddingCharacter != nil {
		in, out := &in.AddTrailingPaddingCharacter, &out.AddTrailingPaddingCharacter
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionTimezone != nil {
		in, out := &in.DatePartitionTimezone, &out.DatePartitionTimezone
		*out = new(string)
		**out = **in
	}
	if in.DetachTargetOnLobLookupFailureParquet != nil {
		in, out := &in.DetachTargetOnLobLookupFailureParquet, &out.DetachTargetOnLobLookupFailureParquet
		*out = new(bool)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.EndpointArn != nil {
		in, out := &in.EndpointArn, &out.EndpointArn
		*out = new(string)
		**out = **in
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.EngineDisplayName != nil {
		in, out := &in.EngineDisplayName, &out.EngineDisplayName
		*out = new(string)
		**out = **in
	}
	if in.ExpectedBucketOwner != nil {
		in, out := &in.ExpectedBucketOwner, &out.ExpectedBucketOwner
		*out = new(string)
		**out = **in
	}
	if in.ExternalID != nil {
		in, out := &in.ExternalID, &out.ExternalID
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TagsAll != nil {
		in, out := &in.TagsAll, &out.TagsAll
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointObservation.
func (in *S3EndpointObservation) DeepCopy() *S3EndpointObservation {
	if in == nil {
		return nil
	}
	out := new(S3EndpointObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointParameters) DeepCopyInto(out *S3EndpointParameters) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.AddTrailingPaddingCharacter != nil {
		in, out := &in.AddTrailingPaddingCharacter, &out.AddTrailingPaddingCharacter
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CertificateArn != nil {
		in, out := &in.CertificateArn, &out.CertificateArn
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionTimezone != nil {
		in, out := &in.DatePartitionTimezone, &out.DatePartitionTimezone
		*out = new(string)
		**out = **in
	}
	if in.DetachTargetOnLobLookupFailureParquet != nil {
		in, out := &in.DetachTargetOnLobLookupFailureParquet, &out.DetachTargetOnLobLookupFailureParquet
		*out = new(bool)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.EndpointType != nil {
		in, out := &in.EndpointType, &out.EndpointType
		*out = new(string)
		**out = **in
	}
	if in.ExpectedBucketOwner != nil {
		in, out := &in.ExpectedBucketOwner, &out.ExpectedBucketOwner
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.KMSKeyArn != nil {
		in, out := &in.KMSKeyArn, &out.KMSKeyArn
		*out = new(string)
		**out = **in
	}
	if in.KMSKeyArnRef != nil {
		in, out := &in.KMSKeyArnRef, &out.KMSKeyArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.KMSKeyArnSelector != nil {
		in, out := &in.KMSKeyArnSelector, &out.KMSKeyArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.SSLMode != nil {
		in, out := &in.SSLMode, &out.SSLMode
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyIDRef != nil {
		in, out := &in.ServerSideEncryptionKMSKeyIDRef, &out.ServerSideEncryptionKMSKeyIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ServerSideEncryptionKMSKeyIDSelector != nil {
		in, out := &in.ServerSideEncryptionKMSKeyIDSelector, &out.ServerSideEncryptionKMSKeyIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArnRef != nil {
		in, out := &in.ServiceAccessRoleArnRef, &out.ServiceAccessRoleArnRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccessRoleArnSelector != nil {
		in, out := &in.ServiceAccessRoleArnSelector, &out.ServiceAccessRoleArnSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointParameters.
func (in *S3EndpointParameters) DeepCopy() *S3EndpointParameters {
	if in == nil {
		return nil
	}
	out := new(S3EndpointParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointSpec) DeepCopyInto(out *S3EndpointSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointSpec.
func (in *S3EndpointSpec) DeepCopy() *S3EndpointSpec {
	if in == nil {
		return nil
	}
	out := new(S3EndpointSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3EndpointStatus) DeepCopyInto(out *S3EndpointStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3EndpointStatus.
func (in *S3EndpointStatus) DeepCopy() *S3EndpointStatus {
	if in == nil {
		return nil
	}
	out := new(S3EndpointStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3SettingsInitParameters) DeepCopyInto(out *S3SettingsInitParameters) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3SettingsInitParameters.
func (in *S3SettingsInitParameters) DeepCopy() *S3SettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(S3SettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3SettingsObservation) DeepCopyInto(out *S3SettingsObservation) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3SettingsObservation.
func (in *S3SettingsObservation) DeepCopy() *S3SettingsObservation {
	if in == nil {
		return nil
	}
	out := new(S3SettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *S3SettingsParameters) DeepCopyInto(out *S3SettingsParameters) {
	*out = *in
	if in.AddColumnName != nil {
		in, out := &in.AddColumnName, &out.AddColumnName
		*out = new(bool)
		**out = **in
	}
	if in.BucketFolder != nil {
		in, out := &in.BucketFolder, &out.BucketFolder
		*out = new(string)
		**out = **in
	}
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.CannedACLForObjects != nil {
		in, out := &in.CannedACLForObjects, &out.CannedACLForObjects
		*out = new(string)
		**out = **in
	}
	if in.CdcInsertsAndUpdates != nil {
		in, out := &in.CdcInsertsAndUpdates, &out.CdcInsertsAndUpdates
		*out = new(bool)
		**out = **in
	}
	if in.CdcInsertsOnly != nil {
		in, out := &in.CdcInsertsOnly, &out.CdcInsertsOnly
		*out = new(bool)
		**out = **in
	}
	if in.CdcMaxBatchInterval != nil {
		in, out := &in.CdcMaxBatchInterval, &out.CdcMaxBatchInterval
		*out = new(int64)
		**out = **in
	}
	if in.CdcMinFileSize != nil {
		in, out := &in.CdcMinFileSize, &out.CdcMinFileSize
		*out = new(int64)
		**out = **in
	}
	if in.CdcPath != nil {
		in, out := &in.CdcPath, &out.CdcPath
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.CsvDelimiter != nil {
		in, out := &in.CsvDelimiter, &out.CsvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.CsvNoSupValue != nil {
		in, out := &in.CsvNoSupValue, &out.CsvNoSupValue
		*out = new(string)
		**out = **in
	}
	if in.CsvNullValue != nil {
		in, out := &in.CsvNullValue, &out.CsvNullValue
		*out = new(string)
		**out = **in
	}
	if in.CsvRowDelimiter != nil {
		in, out := &in.CsvRowDelimiter, &out.CsvRowDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DataFormat != nil {
		in, out := &in.DataFormat, &out.DataFormat
		*out = new(string)
		**out = **in
	}
	if in.DataPageSize != nil {
		in, out := &in.DataPageSize, &out.DataPageSize
		*out = new(int64)
		**out = **in
	}
	if in.DatePartitionDelimiter != nil {
		in, out := &in.DatePartitionDelimiter, &out.DatePartitionDelimiter
		*out = new(string)
		**out = **in
	}
	if in.DatePartitionEnabled != nil {
		in, out := &in.DatePartitionEnabled, &out.DatePartitionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DatePartitionSequence != nil {
		in, out := &in.DatePartitionSequence, &out.DatePartitionSequence
		*out = new(string)
		**out = **in
	}
	if in.DictPageSizeLimit != nil {
		in, out := &in.DictPageSizeLimit, &out.DictPageSizeLimit
		*out = new(int64)
		**out = **in
	}
	if in.EnableStatistics != nil {
		in, out := &in.EnableStatistics, &out.EnableStatistics
		*out = new(bool)
		**out = **in
	}
	if in.EncodingType != nil {
		in, out := &in.EncodingType, &out.EncodingType
		*out = new(string)
		**out = **in
	}
	if in.EncryptionMode != nil {
		in, out := &in.EncryptionMode, &out.EncryptionMode
		*out = new(string)
		**out = **in
	}
	if in.ExternalTableDefinition != nil {
		in, out := &in.ExternalTableDefinition, &out.ExternalTableDefinition
		*out = new(string)
		**out = **in
	}
	if in.IgnoreHeaderRows != nil {
		in, out := &in.IgnoreHeaderRows, &out.IgnoreHeaderRows
		*out = new(int64)
		**out = **in
	}
	if in.IncludeOpForFullLoad != nil {
		in, out := &in.IncludeOpForFullLoad, &out.IncludeOpForFullLoad
		*out = new(bool)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(int64)
		**out = **in
	}
	if in.ParquetTimestampInMillisecond != nil {
		in, out := &in.ParquetTimestampInMillisecond, &out.ParquetTimestampInMillisecond
		*out = new(bool)
		**out = **in
	}
	if in.ParquetVersion != nil {
		in, out := &in.ParquetVersion, &out.ParquetVersion
		*out = new(string)
		**out = **in
	}
	if in.PreserveTransactions != nil {
		in, out := &in.PreserveTransactions, &out.PreserveTransactions
		*out = new(bool)
		**out = **in
	}
	if in.Rfc4180 != nil {
		in, out := &in.Rfc4180, &out.Rfc4180
		*out = new(bool)
		**out = **in
	}
	if in.RowGroupLength != nil {
		in, out := &in.RowGroupLength, &out.RowGroupLength
		*out = new(int64)
		**out = **in
	}
	if in.ServerSideEncryptionKMSKeyID != nil {
		in, out := &in.ServerSideEncryptionKMSKeyID, &out.ServerSideEncryptionKMSKeyID
		*out = new(string)
		**out = **in
	}
	if in.ServiceAccessRoleArn != nil {
		in, out := &in.ServiceAccessRoleArn, &out.ServiceAccessRoleArn
		*out = new(string)
		**out = **in
	}
	if in.TimestampColumnName != nil {
		in, out := &in.TimestampColumnName, &out.TimestampColumnName
		*out = new(string)
		**out = **in
	}
	if in.UseCsvNoSupValue != nil {
		in, out := &in.UseCsvNoSupValue, &out.UseCsvNoSupValue
		*out = new(bool)
		**out = **in
	}
	if in.UseTaskStartTimeForFullLoadTimestamp != nil {
		in, out := &in.UseTaskStartTimeForFullLoadTimestamp, &out.UseTaskStartTimeForFullLoadTimestamp
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new S3SettingsParameters.
func (in *S3SettingsParameters) DeepCopy() *S3SettingsParameters {
	if in == nil {
		return nil
	}
	out := new(S3SettingsParameters)
	in.DeepCopyInto(out)
	return out
}

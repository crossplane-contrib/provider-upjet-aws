/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DestinationPortRangeObservation struct {
}

type DestinationPortRangeParameters struct {

	// Starting port of the range
	// +kubebuilder:validation:Optional
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	// Ending port of the range
	// +kubebuilder:validation:Optional
	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type SourcePortRangeObservation struct {
}

type SourcePortRangeParameters struct {

	// Starting port of the range
	// +kubebuilder:validation:Optional
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	// Ending port of the range
	// +kubebuilder:validation:Optional
	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type TrafficMirrorFilterRuleObservation struct {

	// ARN of the traffic mirror filter rule.
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// Name of the traffic mirror filter rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TrafficMirrorFilterRuleParameters struct {

	// Description of the traffic mirror filter rule.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Destination CIDR block to assign to the Traffic Mirror rule.
	// +kubebuilder:validation:Optional
	DestinationCidrBlock *string `json:"destinationCidrBlock,omitempty" tf:"destination_cidr_block,omitempty"`

	// Destination port range. Supported only when the protocol is set to TCP(6) or UDP(17). See Traffic mirror port range documented below
	// +kubebuilder:validation:Optional
	DestinationPortRange []DestinationPortRangeParameters `json:"destinationPortRange,omitempty" tf:"destination_port_range,omitempty"`

	// Protocol number, for example 17 (UDP), to assign to the Traffic Mirror rule. For information about the protocol value, see Protocol Numbers on the Internet Assigned Numbers Authority (IANA) website.
	// +kubebuilder:validation:Optional
	Protocol *float64 `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// Action to take (accept | reject) on the filtered traffic. Valid values are accept and reject
	// +kubebuilder:validation:Optional
	RuleAction *string `json:"ruleAction,omitempty" tf:"rule_action,omitempty"`

	// Number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
	// +kubebuilder:validation:Optional
	RuleNumber *float64 `json:"ruleNumber,omitempty" tf:"rule_number,omitempty"`

	// Source CIDR block to assign to the Traffic Mirror rule.
	// +kubebuilder:validation:Optional
	SourceCidrBlock *string `json:"sourceCidrBlock,omitempty" tf:"source_cidr_block,omitempty"`

	// Source port range. Supported only when the protocol is set to TCP(6) or UDP(17). See Traffic mirror port range documented below
	// +kubebuilder:validation:Optional
	SourcePortRange []SourcePortRangeParameters `json:"sourcePortRange,omitempty" tf:"source_port_range,omitempty"`

	// Direction of traffic to be captured. Valid values are ingress and egress
	// +kubebuilder:validation:Optional
	TrafficDirection *string `json:"trafficDirection,omitempty" tf:"traffic_direction,omitempty"`

	// ID of the traffic mirror filter to which this rule should be added
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/ec2/v1beta1.TrafficMirrorFilter
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	TrafficMirrorFilterID *string `json:"trafficMirrorFilterId,omitempty" tf:"traffic_mirror_filter_id,omitempty"`

	// Reference to a TrafficMirrorFilter in ec2 to populate trafficMirrorFilterId.
	// +kubebuilder:validation:Optional
	TrafficMirrorFilterIDRef *v1.Reference `json:"trafficMirrorFilterIdRef,omitempty" tf:"-"`

	// Selector for a TrafficMirrorFilter in ec2 to populate trafficMirrorFilterId.
	// +kubebuilder:validation:Optional
	TrafficMirrorFilterIDSelector *v1.Selector `json:"trafficMirrorFilterIdSelector,omitempty" tf:"-"`
}

// TrafficMirrorFilterRuleSpec defines the desired state of TrafficMirrorFilterRule
type TrafficMirrorFilterRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TrafficMirrorFilterRuleParameters `json:"forProvider"`
}

// TrafficMirrorFilterRuleStatus defines the observed state of TrafficMirrorFilterRule.
type TrafficMirrorFilterRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TrafficMirrorFilterRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// TrafficMirrorFilterRule is the Schema for the TrafficMirrorFilterRules API. Provides an Traffic mirror filter rule
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type TrafficMirrorFilterRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.destinationCidrBlock)",message="destinationCidrBlock is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ruleAction)",message="ruleAction is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ruleNumber)",message="ruleNumber is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.sourceCidrBlock)",message="sourceCidrBlock is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.trafficDirection)",message="trafficDirection is a required parameter"
	Spec   TrafficMirrorFilterRuleSpec   `json:"spec"`
	Status TrafficMirrorFilterRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TrafficMirrorFilterRuleList contains a list of TrafficMirrorFilterRules
type TrafficMirrorFilterRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficMirrorFilterRule `json:"items"`
}

// Repository type metadata.
var (
	TrafficMirrorFilterRule_Kind             = "TrafficMirrorFilterRule"
	TrafficMirrorFilterRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TrafficMirrorFilterRule_Kind}.String()
	TrafficMirrorFilterRule_KindAPIVersion   = TrafficMirrorFilterRule_Kind + "." + CRDGroupVersion.String()
	TrafficMirrorFilterRule_GroupVersionKind = CRDGroupVersion.WithKind(TrafficMirrorFilterRule_Kind)
)

func init() {
	SchemeBuilder.Register(&TrafficMirrorFilterRule{}, &TrafficMirrorFilterRuleList{})
}

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionWeightedTargetObservation struct {
}

type ActionWeightedTargetParameters struct {

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type GRPCRouteActionObservation struct {
}

type GRPCRouteActionParameters struct {

	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	WeightedTarget []WeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type GRPCRouteMatchObservation struct {
}

type GRPCRouteMatchParameters struct {

	// Data to match from the gRPC request.
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	// +kubebuilder:validation:Optional
	MethodName *string `json:"methodName,omitempty" tf:"method_name,omitempty"`

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// Fully qualified domain name for the service to match from the request.
	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPRouteActionWeightedTargetObservation struct {
}

type HTTPRouteActionWeightedTargetParameters struct {

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	VirtualNode *string `json:"virtualNode,omitempty" tf:"virtual_node,omitempty"`

	// Reference to a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	VirtualNodeRef *v1.Reference `json:"virtualNodeRef,omitempty" tf:"-"`

	// Selector for a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	VirtualNodeSelector *v1.Selector `json:"virtualNodeSelector,omitempty" tf:"-"`

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type HTTPRouteRetryPolicyObservation struct {
}

type HTTPRouteRetryPolicyParameters struct {

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	MaxRetries *float64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	PerRetryTimeout []HTTPRouteRetryPolicyPerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type HTTPRouteRetryPolicyPerRetryTimeoutObservation struct {
}

type HTTPRouteRetryPolicyPerRetryTimeoutParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type HTTPRouteTimeoutIdleObservation struct {
}

type HTTPRouteTimeoutIdleParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type HTTPRouteTimeoutObservation struct {
}

type HTTPRouteTimeoutParameters struct {

	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	Idle []HTTPRouteTimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// Per request timeout.
	// +kubebuilder:validation:Optional
	PerRequest []HTTPRouteTimeoutPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type HTTPRouteTimeoutPerRequestObservation struct {
}

type HTTPRouteTimeoutPerRequestParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type HeaderMatchObservation struct {
}

type HeaderMatchParameters struct {

	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	Range []MatchRangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type HeaderMatchRangeObservation struct {
}

type HeaderMatchRangeParameters struct {

	// End of the range.
	// +kubebuilder:validation:Required
	End *float64 `json:"end" tf:"end,omitempty"`

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	Start *float64 `json:"start" tf:"start,omitempty"`
}

type HeaderObservation struct {
}

type HeaderParameters struct {

	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	Match []HeaderMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type Http2RouteRetryPolicyObservation struct {
}

type Http2RouteRetryPolicyParameters struct {

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	MaxRetries *float64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	PerRetryTimeout []RetryPolicyPerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type Http2RouteTimeoutObservation struct {
}

type Http2RouteTimeoutParameters struct {

	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	Idle []TimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// Per request timeout.
	// +kubebuilder:validation:Optional
	PerRequest []TimeoutPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type IdleObservation struct {
}

type IdleParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type MatchHeaderMatchObservation struct {
}

type MatchHeaderMatchParameters struct {

	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	Range []HeaderMatchRangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type MatchHeaderObservation struct {
}

type MatchHeaderParameters struct {

	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	Match []MatchHeaderMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type MatchRangeObservation struct {
}

type MatchRangeParameters struct {

	// End of the range.
	// +kubebuilder:validation:Required
	End *float64 `json:"end" tf:"end,omitempty"`

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	Start *float64 `json:"start" tf:"start,omitempty"`
}

type MetadataMatchObservation struct {
}

type MetadataMatchParameters struct {

	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	Range []RangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	Match []MetadataMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type PerRequestObservation struct {
}

type PerRequestParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type PerRetryTimeoutObservation struct {
}

type PerRetryTimeoutParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type RangeObservation struct {
}

type RangeParameters struct {

	// End of the range.
	// +kubebuilder:validation:Required
	End *float64 `json:"end" tf:"end,omitempty"`

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	Start *float64 `json:"start" tf:"start,omitempty"`
}

type RetryPolicyObservation struct {
}

type RetryPolicyParameters struct {

	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	// +kubebuilder:validation:Optional
	GRPCRetryEvents []*string `json:"grpcRetryEvents,omitempty" tf:"grpc_retry_events,omitempty"`

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	MaxRetries *float64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	PerRetryTimeout []PerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type RetryPolicyPerRetryTimeoutObservation struct {
}

type RetryPolicyPerRetryTimeoutParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type RouteObservation struct {

	// ARN of the route.
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// Creation date of the route.
	CreatedDate *string `json:"createdDate,omitempty" tf:"created_date,omitempty"`

	// ID of the route.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Last update date of the route.
	LastUpdatedDate *string `json:"lastUpdatedDate,omitempty" tf:"last_updated_date,omitempty"`

	// Resource owner's AWS account ID.
	ResourceOwner *string `json:"resourceOwner,omitempty" tf:"resource_owner,omitempty"`

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type RouteParameters struct {

	// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.Mesh
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	MeshName *string `json:"meshName,omitempty" tf:"mesh_name,omitempty"`

	// Reference to a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	MeshNameRef *v1.Reference `json:"meshNameRef,omitempty" tf:"-"`

	// Selector for a Mesh in appmesh to populate meshName.
	// +kubebuilder:validation:Optional
	MeshNameSelector *v1.Selector `json:"meshNameSelector,omitempty" tf:"-"`

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	// +kubebuilder:validation:Optional
	MeshOwner *string `json:"meshOwner,omitempty" tf:"mesh_owner,omitempty"`

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// Route specification to apply.
	// +kubebuilder:validation:Required
	Spec []RouteSpecParameters `json:"spec" tf:"spec,omitempty"`

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualRouter
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	VirtualRouterName *string `json:"virtualRouterName,omitempty" tf:"virtual_router_name,omitempty"`

	// Reference to a VirtualRouter in appmesh to populate virtualRouterName.
	// +kubebuilder:validation:Optional
	VirtualRouterNameRef *v1.Reference `json:"virtualRouterNameRef,omitempty" tf:"-"`

	// Selector for a VirtualRouter in appmesh to populate virtualRouterName.
	// +kubebuilder:validation:Optional
	VirtualRouterNameSelector *v1.Selector `json:"virtualRouterNameSelector,omitempty" tf:"-"`
}

type RouteSpecObservation struct {
}

type RouteSpecParameters struct {

	// GRPC routing information for the route.
	// +kubebuilder:validation:Optional
	GRPCRoute []SpecGRPCRouteParameters `json:"grpcRoute,omitempty" tf:"grpc_route,omitempty"`

	// HTTP routing information for the route.
	// +kubebuilder:validation:Optional
	HTTPRoute []SpecHTTPRouteParameters `json:"httpRoute,omitempty" tf:"http_route,omitempty"`

	// HTTP/2 routing information for the route.
	// +kubebuilder:validation:Optional
	Http2Route []SpecHttp2RouteParameters `json:"http2Route,omitempty" tf:"http2_route,omitempty"`

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// TCP routing information for the route.
	// +kubebuilder:validation:Optional
	TCPRoute []TCPRouteParameters `json:"tcpRoute,omitempty" tf:"tcp_route,omitempty"`
}

type SpecGRPCRouteObservation struct {
}

type SpecGRPCRouteParameters struct {

	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	Action []GRPCRouteActionParameters `json:"action" tf:"action,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	Match []GRPCRouteMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// Retry policy.
	// +kubebuilder:validation:Optional
	RetryPolicy []RetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	Timeout []TimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type SpecHTTPRouteActionObservation struct {
}

type SpecHTTPRouteActionParameters struct {

	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	WeightedTarget []HTTPRouteActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type SpecHTTPRouteMatchObservation struct {
}

type SpecHTTPRouteMatchParameters struct {

	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	Header []MatchHeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`
}

type SpecHTTPRouteObservation struct {
}

type SpecHTTPRouteParameters struct {

	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	Action []SpecHTTPRouteActionParameters `json:"action" tf:"action,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Required
	Match []SpecHTTPRouteMatchParameters `json:"match" tf:"match,omitempty"`

	// Retry policy.
	// +kubebuilder:validation:Optional
	RetryPolicy []HTTPRouteRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	Timeout []HTTPRouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type SpecHttp2RouteActionObservation struct {
}

type SpecHttp2RouteActionParameters struct {

	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	WeightedTarget []ActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type SpecHttp2RouteMatchObservation struct {
}

type SpecHttp2RouteMatchParameters struct {

	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`
}

type SpecHttp2RouteObservation struct {
}

type SpecHttp2RouteParameters struct {

	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	Action []SpecHttp2RouteActionParameters `json:"action" tf:"action,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Required
	Match []SpecHttp2RouteMatchParameters `json:"match" tf:"match,omitempty"`

	// Retry policy.
	// +kubebuilder:validation:Optional
	RetryPolicy []Http2RouteRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	Timeout []Http2RouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type TCPRouteActionObservation struct {
}

type TCPRouteActionParameters struct {

	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	WeightedTarget []TCPRouteActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type TCPRouteActionWeightedTargetObservation struct {
}

type TCPRouteActionWeightedTargetParameters struct {

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	VirtualNode *string `json:"virtualNode,omitempty" tf:"virtual_node,omitempty"`

	// Reference to a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	VirtualNodeRef *v1.Reference `json:"virtualNodeRef,omitempty" tf:"-"`

	// Selector for a VirtualNode in appmesh to populate virtualNode.
	// +kubebuilder:validation:Optional
	VirtualNodeSelector *v1.Selector `json:"virtualNodeSelector,omitempty" tf:"-"`

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type TCPRouteMatchObservation struct {
}

type TCPRouteMatchParameters struct {

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type TCPRouteObservation struct {
}

type TCPRouteParameters struct {

	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	Action []TCPRouteActionParameters `json:"action" tf:"action,omitempty"`

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	Match []TCPRouteMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	Timeout []TCPRouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type TCPRouteTimeoutIdleObservation struct {
}

type TCPRouteTimeoutIdleParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type TCPRouteTimeoutObservation struct {
}

type TCPRouteTimeoutParameters struct {

	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	Idle []TCPRouteTimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`
}

type TimeoutIdleObservation struct {
}

type TimeoutIdleParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type TimeoutObservation struct {
}

type TimeoutParameters struct {

	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	Idle []IdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// Per request timeout.
	// +kubebuilder:validation:Optional
	PerRequest []PerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type TimeoutPerRequestObservation struct {
}

type TimeoutPerRequestParameters struct {

	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type WeightedTargetObservation struct {
}

type WeightedTargetParameters struct {

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

// RouteSpec defines the desired state of Route
type RouteSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RouteParameters `json:"forProvider"`
}

// RouteStatus defines the observed state of Route.
type RouteStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RouteObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Route is the Schema for the Routes API. Provides an AWS App Mesh route resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Route struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RouteSpec   `json:"spec"`
	Status            RouteStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RouteList contains a list of Routes
type RouteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Route `json:"items"`
}

// Repository type metadata.
var (
	Route_Kind             = "Route"
	Route_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Route_Kind}.String()
	Route_KindAPIVersion   = Route_Kind + "." + CRDGroupVersion.String()
	Route_GroupVersionKind = CRDGroupVersion.WithKind(Route_Kind)
)

func init() {
	SchemeBuilder.Register(&Route{}, &RouteList{})
}

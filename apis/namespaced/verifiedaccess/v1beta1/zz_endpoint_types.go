// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type CidrOptionsInitParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.Subnet
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("cidr_block",false)
	Cidr *string `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// Reference to a Subnet in ec2 to populate cidr.
	// +kubebuilder:validation:Optional
	CidrRef *v1.NamespacedReference `json:"cidrRef,omitempty" tf:"-"`

	// Selector for a Subnet in ec2 to populate cidr.
	// +kubebuilder:validation:Optional
	CidrSelector *v1.NamespacedSelector `json:"cidrSelector,omitempty" tf:"-"`

	PortRange []PortRangeInitParameters `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type CidrOptionsObservation struct {
	Cidr *string `json:"cidr,omitempty" tf:"cidr,omitempty"`

	PortRange []PortRangeObservation `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type CidrOptionsParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.Subnet
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("cidr_block",false)
	// +kubebuilder:validation:Optional
	Cidr *string `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// Reference to a Subnet in ec2 to populate cidr.
	// +kubebuilder:validation:Optional
	CidrRef *v1.NamespacedReference `json:"cidrRef,omitempty" tf:"-"`

	// Selector for a Subnet in ec2 to populate cidr.
	// +kubebuilder:validation:Optional
	CidrSelector *v1.NamespacedSelector `json:"cidrSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PortRange []PortRangeParameters `json:"portRange" tf:"port_range,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type EndpointInitParameters struct {

	// The DNS name for users to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	ApplicationDomain *string `json:"applicationDomain,omitempty" tf:"application_domain,omitempty"`

	// The type of attachment. Currently, only vpc is supported.
	AttachmentType *string `json:"attachmentType,omitempty" tf:"attachment_type,omitempty"`

	// The CIDR block details. This parameter is required if the endpoint type is cidr.
	CidrOptions *CidrOptionsInitParameters `json:"cidrOptions,omitempty" tf:"cidr_options,omitempty"`

	// A description for the Verified Access endpoint.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// - The ARN of the public TLS/SSL certificate in AWS Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/acm/v1beta1.Certificate
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("arn",true)
	DomainCertificateArn *string `json:"domainCertificateArn,omitempty" tf:"domain_certificate_arn,omitempty"`

	// Reference to a Certificate in acm to populate domainCertificateArn.
	// +kubebuilder:validation:Optional
	DomainCertificateArnRef *v1.NamespacedReference `json:"domainCertificateArnRef,omitempty" tf:"-"`

	// Selector for a Certificate in acm to populate domainCertificateArn.
	// +kubebuilder:validation:Optional
	DomainCertificateArnSelector *v1.NamespacedSelector `json:"domainCertificateArnSelector,omitempty" tf:"-"`

	// - A custom identifier that is prepended to the DNS name that is generated for the endpoint.
	EndpointDomainPrefix *string `json:"endpointDomainPrefix,omitempty" tf:"endpoint_domain_prefix,omitempty"`

	// - The type of Verified Access endpoint to create. Currently load-balancer or network-interface are supported.
	EndpointType *string `json:"endpointType,omitempty" tf:"endpoint_type,omitempty"`

	// The load balancer details. This parameter is required if the endpoint type is load-balancer.
	LoadBalancerOptions *LoadBalancerOptionsInitParameters `json:"loadBalancerOptions,omitempty" tf:"load_balancer_options,omitempty"`

	// The network interface details. This parameter is required if the endpoint type is network-interface.
	NetworkInterfaceOptions *NetworkInterfaceOptionsInitParameters `json:"networkInterfaceOptions,omitempty" tf:"network_interface_options,omitempty"`

	// The policy document that is associated with this resource.
	PolicyDocument *string `json:"policyDocument,omitempty" tf:"policy_document,omitempty"`

	RDSOptions *RDSOptionsInitParameters `json:"rdsOptions,omitempty" tf:"rds_options,omitempty"`

	// References to SecurityGroup in ec2 to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDRefs []v1.NamespacedReference `json:"securityGroupIdRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDSelector *v1.NamespacedSelector `json:"securityGroupIdSelector,omitempty" tf:"-"`

	// List of the the security groups IDs to associate with the Verified Access endpoint.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupIDRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupIDSelector
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// The options in use for server side encryption.
	SseSpecification *SseSpecificationInitParameters `json:"sseSpecification,omitempty" tf:"sse_specification,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The ID of the Verified Access group to associate the endpoint with.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/verifiedaccess/v1beta1.Group
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	VerifiedAccessGroupID *string `json:"verifiedAccessGroupId,omitempty" tf:"verified_access_group_id,omitempty"`

	// Reference to a Group in verifiedaccess to populate verifiedAccessGroupId.
	// +kubebuilder:validation:Optional
	VerifiedAccessGroupIDRef *v1.NamespacedReference `json:"verifiedAccessGroupIdRef,omitempty" tf:"-"`

	// Selector for a Group in verifiedaccess to populate verifiedAccessGroupId.
	// +kubebuilder:validation:Optional
	VerifiedAccessGroupIDSelector *v1.NamespacedSelector `json:"verifiedAccessGroupIdSelector,omitempty" tf:"-"`
}

type EndpointObservation struct {

	// The DNS name for users to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	ApplicationDomain *string `json:"applicationDomain,omitempty" tf:"application_domain,omitempty"`

	// The type of attachment. Currently, only vpc is supported.
	AttachmentType *string `json:"attachmentType,omitempty" tf:"attachment_type,omitempty"`

	// The CIDR block details. This parameter is required if the endpoint type is cidr.
	CidrOptions *CidrOptionsObservation `json:"cidrOptions,omitempty" tf:"cidr_options,omitempty"`

	// A description for the Verified Access endpoint.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Returned if endpoint has a device trust provider attached.
	DeviceValidationDomain *string `json:"deviceValidationDomain,omitempty" tf:"device_validation_domain,omitempty"`

	// - The ARN of the public TLS/SSL certificate in AWS Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	DomainCertificateArn *string `json:"domainCertificateArn,omitempty" tf:"domain_certificate_arn,omitempty"`

	// A DNS name that is generated for the endpoint.
	EndpointDomain *string `json:"endpointDomain,omitempty" tf:"endpoint_domain,omitempty"`

	// - A custom identifier that is prepended to the DNS name that is generated for the endpoint.
	EndpointDomainPrefix *string `json:"endpointDomainPrefix,omitempty" tf:"endpoint_domain_prefix,omitempty"`

	// - The type of Verified Access endpoint to create. Currently load-balancer or network-interface are supported.
	EndpointType *string `json:"endpointType,omitempty" tf:"endpoint_type,omitempty"`

	// The ID of the AWS Verified Access endpoint.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The load balancer details. This parameter is required if the endpoint type is load-balancer.
	LoadBalancerOptions *LoadBalancerOptionsObservation `json:"loadBalancerOptions,omitempty" tf:"load_balancer_options,omitempty"`

	// The network interface details. This parameter is required if the endpoint type is network-interface.
	NetworkInterfaceOptions *NetworkInterfaceOptionsObservation `json:"networkInterfaceOptions,omitempty" tf:"network_interface_options,omitempty"`

	// The policy document that is associated with this resource.
	PolicyDocument *string `json:"policyDocument,omitempty" tf:"policy_document,omitempty"`

	RDSOptions *RDSOptionsObservation `json:"rdsOptions,omitempty" tf:"rds_options,omitempty"`

	// Region where this resource will be managed. Defaults to the Region set in the provider configuration.
	// Region is the region you'd like your resource to be created in.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// List of the the security groups IDs to associate with the Verified Access endpoint.
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// The options in use for server side encryption.
	SseSpecification *SseSpecificationObservation `json:"sseSpecification,omitempty" tf:"sse_specification,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +mapType=granular
	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	// The ID of the Verified Access group to associate the endpoint with.
	VerifiedAccessGroupID *string `json:"verifiedAccessGroupId,omitempty" tf:"verified_access_group_id,omitempty"`

	// The ID of the AWS Verified Access endpoint.
	VerifiedAccessInstanceID *string `json:"verifiedAccessInstanceId,omitempty" tf:"verified_access_instance_id,omitempty"`
}

type EndpointParameters struct {

	// The DNS name for users to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	// +kubebuilder:validation:Optional
	ApplicationDomain *string `json:"applicationDomain,omitempty" tf:"application_domain,omitempty"`

	// The type of attachment. Currently, only vpc is supported.
	// +kubebuilder:validation:Optional
	AttachmentType *string `json:"attachmentType,omitempty" tf:"attachment_type,omitempty"`

	// The CIDR block details. This parameter is required if the endpoint type is cidr.
	// +kubebuilder:validation:Optional
	CidrOptions *CidrOptionsParameters `json:"cidrOptions,omitempty" tf:"cidr_options,omitempty"`

	// A description for the Verified Access endpoint.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// - The ARN of the public TLS/SSL certificate in AWS Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application. This parameter is required if the endpoint type is load-balancer or network-interface.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/acm/v1beta1.Certificate
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("arn",true)
	// +kubebuilder:validation:Optional
	DomainCertificateArn *string `json:"domainCertificateArn,omitempty" tf:"domain_certificate_arn,omitempty"`

	// Reference to a Certificate in acm to populate domainCertificateArn.
	// +kubebuilder:validation:Optional
	DomainCertificateArnRef *v1.NamespacedReference `json:"domainCertificateArnRef,omitempty" tf:"-"`

	// Selector for a Certificate in acm to populate domainCertificateArn.
	// +kubebuilder:validation:Optional
	DomainCertificateArnSelector *v1.NamespacedSelector `json:"domainCertificateArnSelector,omitempty" tf:"-"`

	// - A custom identifier that is prepended to the DNS name that is generated for the endpoint.
	// +kubebuilder:validation:Optional
	EndpointDomainPrefix *string `json:"endpointDomainPrefix,omitempty" tf:"endpoint_domain_prefix,omitempty"`

	// - The type of Verified Access endpoint to create. Currently load-balancer or network-interface are supported.
	// +kubebuilder:validation:Optional
	EndpointType *string `json:"endpointType,omitempty" tf:"endpoint_type,omitempty"`

	// The load balancer details. This parameter is required if the endpoint type is load-balancer.
	// +kubebuilder:validation:Optional
	LoadBalancerOptions *LoadBalancerOptionsParameters `json:"loadBalancerOptions,omitempty" tf:"load_balancer_options,omitempty"`

	// The network interface details. This parameter is required if the endpoint type is network-interface.
	// +kubebuilder:validation:Optional
	NetworkInterfaceOptions *NetworkInterfaceOptionsParameters `json:"networkInterfaceOptions,omitempty" tf:"network_interface_options,omitempty"`

	// The policy document that is associated with this resource.
	// +kubebuilder:validation:Optional
	PolicyDocument *string `json:"policyDocument,omitempty" tf:"policy_document,omitempty"`

	// +kubebuilder:validation:Optional
	RDSOptions *RDSOptionsParameters `json:"rdsOptions,omitempty" tf:"rds_options,omitempty"`

	// Region where this resource will be managed. Defaults to the Region set in the provider configuration.
	// Region is the region you'd like your resource to be created in.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// References to SecurityGroup in ec2 to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDRefs []v1.NamespacedReference `json:"securityGroupIdRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDSelector *v1.NamespacedSelector `json:"securityGroupIdSelector,omitempty" tf:"-"`

	// List of the the security groups IDs to associate with the Verified Access endpoint.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupIDRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupIDSelector
	// +kubebuilder:validation:Optional
	// +listType=set
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// The options in use for server side encryption.
	// +kubebuilder:validation:Optional
	SseSpecification *SseSpecificationParameters `json:"sseSpecification,omitempty" tf:"sse_specification,omitempty"`

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The ID of the Verified Access group to associate the endpoint with.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/verifiedaccess/v1beta1.Group
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	VerifiedAccessGroupID *string `json:"verifiedAccessGroupId,omitempty" tf:"verified_access_group_id,omitempty"`

	// Reference to a Group in verifiedaccess to populate verifiedAccessGroupId.
	// +kubebuilder:validation:Optional
	VerifiedAccessGroupIDRef *v1.NamespacedReference `json:"verifiedAccessGroupIdRef,omitempty" tf:"-"`

	// Selector for a Group in verifiedaccess to populate verifiedAccessGroupId.
	// +kubebuilder:validation:Optional
	VerifiedAccessGroupIDSelector *v1.NamespacedSelector `json:"verifiedAccessGroupIdSelector,omitempty" tf:"-"`
}

type LoadBalancerOptionsInitParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/elbv2/v1beta1.LB
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("arn",true)
	LoadBalancerArn *string `json:"loadBalancerArn,omitempty" tf:"load_balancer_arn,omitempty"`

	// Reference to a LB in elbv2 to populate loadBalancerArn.
	// +kubebuilder:validation:Optional
	LoadBalancerArnRef *v1.NamespacedReference `json:"loadBalancerArnRef,omitempty" tf:"-"`

	// Selector for a LB in elbv2 to populate loadBalancerArn.
	// +kubebuilder:validation:Optional
	LoadBalancerArnSelector *v1.NamespacedSelector `json:"loadBalancerArnSelector,omitempty" tf:"-"`

	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	PortRange []LoadBalancerOptionsPortRangeInitParameters `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.Subnet
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in ec2 to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.NamespacedReference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in ec2 to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.NamespacedSelector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type LoadBalancerOptionsObservation struct {
	LoadBalancerArn *string `json:"loadBalancerArn,omitempty" tf:"load_balancer_arn,omitempty"`

	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	PortRange []LoadBalancerOptionsPortRangeObservation `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type LoadBalancerOptionsParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/elbv2/v1beta1.LB
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("arn",true)
	// +kubebuilder:validation:Optional
	LoadBalancerArn *string `json:"loadBalancerArn,omitempty" tf:"load_balancer_arn,omitempty"`

	// Reference to a LB in elbv2 to populate loadBalancerArn.
	// +kubebuilder:validation:Optional
	LoadBalancerArnRef *v1.NamespacedReference `json:"loadBalancerArnRef,omitempty" tf:"-"`

	// Selector for a LB in elbv2 to populate loadBalancerArn.
	// +kubebuilder:validation:Optional
	LoadBalancerArnSelector *v1.NamespacedSelector `json:"loadBalancerArnSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	PortRange []LoadBalancerOptionsPortRangeParameters `json:"portRange,omitempty" tf:"port_range,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.Subnet
	// +kubebuilder:validation:Optional
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// References to Subnet in ec2 to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsRefs []v1.NamespacedReference `json:"subnetIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Subnet in ec2 to populate subnetIds.
	// +kubebuilder:validation:Optional
	SubnetIdsSelector *v1.NamespacedSelector `json:"subnetIdsSelector,omitempty" tf:"-"`
}

type LoadBalancerOptionsPortRangeInitParameters struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type LoadBalancerOptionsPortRangeObservation struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type LoadBalancerOptionsPortRangeParameters struct {

	// +kubebuilder:validation:Optional
	FromPort *float64 `json:"fromPort" tf:"from_port,omitempty"`

	// +kubebuilder:validation:Optional
	ToPort *float64 `json:"toPort" tf:"to_port,omitempty"`
}

type NetworkInterfaceOptionsInitParameters struct {

	// The ID of the AWS Verified Access endpoint.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.NetworkInterface
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id,omitempty"`

	// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
	// +kubebuilder:validation:Optional
	NetworkInterfaceIDRef *v1.NamespacedReference `json:"networkInterfaceIdRef,omitempty" tf:"-"`

	// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
	// +kubebuilder:validation:Optional
	NetworkInterfaceIDSelector *v1.NamespacedSelector `json:"networkInterfaceIdSelector,omitempty" tf:"-"`

	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	PortRange []NetworkInterfaceOptionsPortRangeInitParameters `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type NetworkInterfaceOptionsObservation struct {

	// The ID of the AWS Verified Access endpoint.
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id,omitempty"`

	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	PortRange []NetworkInterfaceOptionsPortRangeObservation `json:"portRange,omitempty" tf:"port_range,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type NetworkInterfaceOptionsParameters struct {

	// The ID of the AWS Verified Access endpoint.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/ec2/v1beta1.NetworkInterface
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id,omitempty"`

	// Reference to a NetworkInterface in ec2 to populate networkInterfaceId.
	// +kubebuilder:validation:Optional
	NetworkInterfaceIDRef *v1.NamespacedReference `json:"networkInterfaceIdRef,omitempty" tf:"-"`

	// Selector for a NetworkInterface in ec2 to populate networkInterfaceId.
	// +kubebuilder:validation:Optional
	NetworkInterfaceIDSelector *v1.NamespacedSelector `json:"networkInterfaceIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	PortRange []NetworkInterfaceOptionsPortRangeParameters `json:"portRange,omitempty" tf:"port_range,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type NetworkInterfaceOptionsPortRangeInitParameters struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type NetworkInterfaceOptionsPortRangeObservation struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type NetworkInterfaceOptionsPortRangeParameters struct {

	// +kubebuilder:validation:Optional
	FromPort *float64 `json:"fromPort" tf:"from_port,omitempty"`

	// +kubebuilder:validation:Optional
	ToPort *float64 `json:"toPort" tf:"to_port,omitempty"`
}

type PortRangeInitParameters struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type PortRangeObservation struct {
	FromPort *float64 `json:"fromPort,omitempty" tf:"from_port,omitempty"`

	ToPort *float64 `json:"toPort,omitempty" tf:"to_port,omitempty"`
}

type PortRangeParameters struct {

	// +kubebuilder:validation:Optional
	FromPort *float64 `json:"fromPort" tf:"from_port,omitempty"`

	// +kubebuilder:validation:Optional
	ToPort *float64 `json:"toPort" tf:"to_port,omitempty"`
}

type RDSOptionsInitParameters struct {
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	RDSDBClusterArn *string `json:"rdsDbClusterArn,omitempty" tf:"rds_db_cluster_arn,omitempty"`

	RDSDBInstanceArn *string `json:"rdsDbInstanceArn,omitempty" tf:"rds_db_instance_arn,omitempty"`

	RDSDBProxyArn *string `json:"rdsDbProxyArn,omitempty" tf:"rds_db_proxy_arn,omitempty"`

	RDSEndpoint *string `json:"rdsEndpoint,omitempty" tf:"rds_endpoint,omitempty"`

	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type RDSOptionsObservation struct {
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	RDSDBClusterArn *string `json:"rdsDbClusterArn,omitempty" tf:"rds_db_cluster_arn,omitempty"`

	RDSDBInstanceArn *string `json:"rdsDbInstanceArn,omitempty" tf:"rds_db_instance_arn,omitempty"`

	RDSDBProxyArn *string `json:"rdsDbProxyArn,omitempty" tf:"rds_db_proxy_arn,omitempty"`

	RDSEndpoint *string `json:"rdsEndpoint,omitempty" tf:"rds_endpoint,omitempty"`

	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type RDSOptionsParameters struct {

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	RDSDBClusterArn *string `json:"rdsDbClusterArn,omitempty" tf:"rds_db_cluster_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RDSDBInstanceArn *string `json:"rdsDbInstanceArn,omitempty" tf:"rds_db_instance_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RDSDBProxyArn *string `json:"rdsDbProxyArn,omitempty" tf:"rds_db_proxy_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RDSEndpoint *string `json:"rdsEndpoint,omitempty" tf:"rds_endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	// +listType=set
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type SseSpecificationInitParameters struct {
	CustomerManagedKeyEnabled *bool `json:"customerManagedKeyEnabled,omitempty" tf:"customer_managed_key_enabled,omitempty"`

	KMSKeyArn *string `json:"kmsKeyArn,omitempty" tf:"kms_key_arn,omitempty"`
}

type SseSpecificationObservation struct {
	CustomerManagedKeyEnabled *bool `json:"customerManagedKeyEnabled,omitempty" tf:"customer_managed_key_enabled,omitempty"`

	KMSKeyArn *string `json:"kmsKeyArn,omitempty" tf:"kms_key_arn,omitempty"`
}

type SseSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	CustomerManagedKeyEnabled *bool `json:"customerManagedKeyEnabled,omitempty" tf:"customer_managed_key_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyArn *string `json:"kmsKeyArn,omitempty" tf:"kms_key_arn,omitempty"`
}

// EndpointSpec defines the desired state of Endpoint
type EndpointSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            EndpointParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider EndpointInitParameters `json:"initProvider,omitempty"`
}

// EndpointStatus defines the observed state of Endpoint.
type EndpointStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EndpointObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Endpoint is the Schema for the Endpoints API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,aws}
type Endpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.attachmentType) || (has(self.initProvider) && has(self.initProvider.attachmentType))",message="spec.forProvider.attachmentType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.endpointType) || (has(self.initProvider) && has(self.initProvider.endpointType))",message="spec.forProvider.endpointType is a required parameter"
	Spec   EndpointSpec   `json:"spec"`
	Status EndpointStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EndpointList contains a list of Endpoints
type EndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Endpoint `json:"items"`
}

// Repository type metadata.
var (
	Endpoint_Kind             = "Endpoint"
	Endpoint_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Endpoint_Kind}.String()
	Endpoint_KindAPIVersion   = Endpoint_Kind + "." + CRDGroupVersion.String()
	Endpoint_GroupVersionKind = CRDGroupVersion.WithKind(Endpoint_Kind)
)

func init() {
	SchemeBuilder.Register(&Endpoint{}, &EndpointList{})
}

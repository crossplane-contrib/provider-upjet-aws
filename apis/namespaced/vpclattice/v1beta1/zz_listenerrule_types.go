// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type ActionFixedResponseInitParameters struct {

	// The HTTP response code.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type ActionFixedResponseObservation struct {

	// The HTTP response code.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type ActionFixedResponseParameters struct {

	// The HTTP response code.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode" tf:"status_code,omitempty"`
}

type ActionForwardInitParameters struct {

	// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
	TargetGroups []ForwardTargetGroupsInitParameters `json:"targetGroups,omitempty" tf:"target_groups,omitempty"`
}

type ActionForwardObservation struct {

	// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
	TargetGroups []ForwardTargetGroupsObservation `json:"targetGroups,omitempty" tf:"target_groups,omitempty"`
}

type ActionForwardParameters struct {

	// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
	// +kubebuilder:validation:Optional
	TargetGroups []ForwardTargetGroupsParameters `json:"targetGroups" tf:"target_groups,omitempty"`
}

type ActionInitParameters struct {

	// Describes the rule action that returns a custom HTTP response.
	// See fixed_response Block for details.
	FixedResponse *ActionFixedResponseInitParameters `json:"fixedResponse,omitempty" tf:"fixed_response,omitempty"`

	// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
	// See forward Block for details.
	Forward *ActionForwardInitParameters `json:"forward,omitempty" tf:"forward,omitempty"`
}

type ActionObservation struct {

	// Describes the rule action that returns a custom HTTP response.
	// See fixed_response Block for details.
	FixedResponse *ActionFixedResponseObservation `json:"fixedResponse,omitempty" tf:"fixed_response,omitempty"`

	// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
	// See forward Block for details.
	Forward *ActionForwardObservation `json:"forward,omitempty" tf:"forward,omitempty"`
}

type ActionParameters struct {

	// Describes the rule action that returns a custom HTTP response.
	// See fixed_response Block for details.
	// +kubebuilder:validation:Optional
	FixedResponse *ActionFixedResponseParameters `json:"fixedResponse,omitempty" tf:"fixed_response,omitempty"`

	// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
	// See forward Block for details.
	// +kubebuilder:validation:Optional
	Forward *ActionForwardParameters `json:"forward,omitempty" tf:"forward,omitempty"`
}

type ForwardTargetGroupsInitParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.TargetGroup
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	TargetGroupIdentifier *string `json:"targetGroupIdentifier,omitempty" tf:"target_group_identifier,omitempty"`

	// Reference to a TargetGroup in vpclattice to populate targetGroupIdentifier.
	// +kubebuilder:validation:Optional
	TargetGroupIdentifierRef *v1.NamespacedReference `json:"targetGroupIdentifierRef,omitempty" tf:"-"`

	// Selector for a TargetGroup in vpclattice to populate targetGroupIdentifier.
	// +kubebuilder:validation:Optional
	TargetGroupIdentifierSelector *v1.NamespacedSelector `json:"targetGroupIdentifierSelector,omitempty" tf:"-"`

	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type ForwardTargetGroupsObservation struct {
	TargetGroupIdentifier *string `json:"targetGroupIdentifier,omitempty" tf:"target_group_identifier,omitempty"`

	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type ForwardTargetGroupsParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.TargetGroup
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	TargetGroupIdentifier *string `json:"targetGroupIdentifier,omitempty" tf:"target_group_identifier,omitempty"`

	// Reference to a TargetGroup in vpclattice to populate targetGroupIdentifier.
	// +kubebuilder:validation:Optional
	TargetGroupIdentifierRef *v1.NamespacedReference `json:"targetGroupIdentifierRef,omitempty" tf:"-"`

	// Selector for a TargetGroup in vpclattice to populate targetGroupIdentifier.
	// +kubebuilder:validation:Optional
	TargetGroupIdentifierSelector *v1.NamespacedSelector `json:"targetGroupIdentifierSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPMatchInitParameters struct {

	// The header matches.
	// Matches incoming requests with rule based on request header value before applying rule action.
	// See header_matches Block for details.
	HeaderMatches []HeaderMatchesInitParameters `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// The HTTP method type.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The path match.
	// See path_match Block for details.
	PathMatch *PathMatchInitParameters `json:"pathMatch,omitempty" tf:"path_match,omitempty"`
}

type HTTPMatchObservation struct {

	// The header matches.
	// Matches incoming requests with rule based on request header value before applying rule action.
	// See header_matches Block for details.
	HeaderMatches []HeaderMatchesObservation `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// The HTTP method type.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The path match.
	// See path_match Block for details.
	PathMatch *PathMatchObservation `json:"pathMatch,omitempty" tf:"path_match,omitempty"`
}

type HTTPMatchParameters struct {

	// The header matches.
	// Matches incoming requests with rule based on request header value before applying rule action.
	// See header_matches Block for details.
	// +kubebuilder:validation:Optional
	HeaderMatches []HeaderMatchesParameters `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// The HTTP method type.
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The path match.
	// See path_match Block for details.
	// +kubebuilder:validation:Optional
	PathMatch *PathMatchParameters `json:"pathMatch,omitempty" tf:"path_match,omitempty"`
}

type HeaderMatchesInitParameters struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Header Match  for details.
	Match *HeaderMatchesMatchInitParameters `json:"match,omitempty" tf:"match,omitempty"`

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type HeaderMatchesMatchInitParameters struct {

	// Specifies a contains type match.
	Contains *string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Specifies an exact type match.
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type HeaderMatchesMatchObservation struct {

	// Specifies a contains type match.
	Contains *string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Specifies an exact type match.
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type HeaderMatchesMatchParameters struct {

	// Specifies a contains type match.
	// +kubebuilder:validation:Optional
	Contains *string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Specifies an exact type match.
	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type HeaderMatchesObservation struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Header Match  for details.
	Match *HeaderMatchesMatchObservation `json:"match,omitempty" tf:"match,omitempty"`

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type HeaderMatchesParameters struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Header Match  for details.
	// +kubebuilder:validation:Optional
	Match *HeaderMatchesMatchParameters `json:"match" tf:"match,omitempty"`

	// The name of the header.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type ListenerRuleInitParameters struct {

	// The action for the listener rule.
	// See action Block for details.
	Action *ActionInitParameters `json:"action,omitempty" tf:"action,omitempty"`

	// The ID or Amazon Resource Name (ARN) of the listener.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.Listener
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("listener_id",true)
	ListenerIdentifier *string `json:"listenerIdentifier,omitempty" tf:"listener_identifier,omitempty"`

	// Reference to a Listener in vpclattice to populate listenerIdentifier.
	// +kubebuilder:validation:Optional
	ListenerIdentifierRef *v1.NamespacedReference `json:"listenerIdentifierRef,omitempty" tf:"-"`

	// Selector for a Listener in vpclattice to populate listenerIdentifier.
	// +kubebuilder:validation:Optional
	ListenerIdentifierSelector *v1.NamespacedSelector `json:"listenerIdentifierSelector,omitempty" tf:"-"`

	// The rule match.
	// See match Block
	Match *MatchInitParameters `json:"match,omitempty" tf:"match,omitempty"`

	// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// The ID or Amazon Resource Identifier (ARN) of the service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.Service
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	ServiceIdentifier *string `json:"serviceIdentifier,omitempty" tf:"service_identifier,omitempty"`

	// Reference to a Service in vpclattice to populate serviceIdentifier.
	// +kubebuilder:validation:Optional
	ServiceIdentifierRef *v1.NamespacedReference `json:"serviceIdentifierRef,omitempty" tf:"-"`

	// Selector for a Service in vpclattice to populate serviceIdentifier.
	// +kubebuilder:validation:Optional
	ServiceIdentifierSelector *v1.NamespacedSelector `json:"serviceIdentifierSelector,omitempty" tf:"-"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ListenerRuleObservation struct {

	// The action for the listener rule.
	// See action Block for details.
	Action *ActionObservation `json:"action,omitempty" tf:"action,omitempty"`

	// The ARN for the listener rule.
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The ID or Amazon Resource Name (ARN) of the listener.
	ListenerIdentifier *string `json:"listenerIdentifier,omitempty" tf:"listener_identifier,omitempty"`

	// The rule match.
	// See match Block
	Match *MatchObservation `json:"match,omitempty" tf:"match,omitempty"`

	// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Region where this resource will be managed. Defaults to the Region set in the provider configuration.
	// Region is the region you'd like your resource to be created in.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Unique identifier for the listener rule.
	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	// The ID or Amazon Resource Identifier (ARN) of the service.
	ServiceIdentifier *string `json:"serviceIdentifier,omitempty" tf:"service_identifier,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	// +mapType=granular
	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type ListenerRuleParameters struct {

	// The action for the listener rule.
	// See action Block for details.
	// +kubebuilder:validation:Optional
	Action *ActionParameters `json:"action,omitempty" tf:"action,omitempty"`

	// The ID or Amazon Resource Name (ARN) of the listener.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.Listener
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("listener_id",true)
	// +kubebuilder:validation:Optional
	ListenerIdentifier *string `json:"listenerIdentifier,omitempty" tf:"listener_identifier,omitempty"`

	// Reference to a Listener in vpclattice to populate listenerIdentifier.
	// +kubebuilder:validation:Optional
	ListenerIdentifierRef *v1.NamespacedReference `json:"listenerIdentifierRef,omitempty" tf:"-"`

	// Selector for a Listener in vpclattice to populate listenerIdentifier.
	// +kubebuilder:validation:Optional
	ListenerIdentifierSelector *v1.NamespacedSelector `json:"listenerIdentifierSelector,omitempty" tf:"-"`

	// The rule match.
	// See match Block
	// +kubebuilder:validation:Optional
	Match *MatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Region where this resource will be managed. Defaults to the Region set in the provider configuration.
	// Region is the region you'd like your resource to be created in.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// The ID or Amazon Resource Identifier (ARN) of the service.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/namespaced/vpclattice/v1beta1.Service
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	ServiceIdentifier *string `json:"serviceIdentifier,omitempty" tf:"service_identifier,omitempty"`

	// Reference to a Service in vpclattice to populate serviceIdentifier.
	// +kubebuilder:validation:Optional
	ServiceIdentifierRef *v1.NamespacedReference `json:"serviceIdentifierRef,omitempty" tf:"-"`

	// Selector for a Service in vpclattice to populate serviceIdentifier.
	// +kubebuilder:validation:Optional
	ServiceIdentifierSelector *v1.NamespacedSelector `json:"serviceIdentifierSelector,omitempty" tf:"-"`

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type MatchInitParameters struct {

	// The HTTP criteria that a rule must match.
	// See http_match Block for details.
	HTTPMatch *HTTPMatchInitParameters `json:"httpMatch,omitempty" tf:"http_match,omitempty"`
}

type MatchObservation struct {

	// The HTTP criteria that a rule must match.
	// See http_match Block for details.
	HTTPMatch *HTTPMatchObservation `json:"httpMatch,omitempty" tf:"http_match,omitempty"`
}

type MatchParameters struct {

	// The HTTP criteria that a rule must match.
	// See http_match Block for details.
	// +kubebuilder:validation:Optional
	HTTPMatch *HTTPMatchParameters `json:"httpMatch" tf:"http_match,omitempty"`
}

type PathMatchInitParameters struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Path Match  for details.
	Match *PathMatchMatchInitParameters `json:"match,omitempty" tf:"match,omitempty"`
}

type PathMatchMatchInitParameters struct {

	// Specifies an exact type match.
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type PathMatchMatchObservation struct {

	// Specifies an exact type match.
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type PathMatchMatchParameters struct {

	// Specifies an exact type match.
	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// Specifies a prefix type match.
	// Matches the value with the prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type PathMatchObservation struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Path Match  for details.
	Match *PathMatchMatchObservation `json:"match,omitempty" tf:"match,omitempty"`
}

type PathMatchParameters struct {

	// Indicates whether the match is case sensitive.
	// Default is false.
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// The header match type.
	// See Path Match  for details.
	// +kubebuilder:validation:Optional
	Match *PathMatchMatchParameters `json:"match" tf:"match,omitempty"`
}

// ListenerRuleSpec defines the desired state of ListenerRule
type ListenerRuleSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            ListenerRuleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ListenerRuleInitParameters `json:"initProvider,omitempty"`
}

// ListenerRuleStatus defines the observed state of ListenerRule.
type ListenerRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ListenerRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ListenerRule is the Schema for the ListenerRules API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,aws}
type ListenerRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.action) || (has(self.initProvider) && has(self.initProvider.action))",message="spec.forProvider.action is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.match) || (has(self.initProvider) && has(self.initProvider.match))",message="spec.forProvider.match is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.priority) || (has(self.initProvider) && has(self.initProvider.priority))",message="spec.forProvider.priority is a required parameter"
	Spec   ListenerRuleSpec   `json:"spec"`
	Status ListenerRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ListenerRuleList contains a list of ListenerRules
type ListenerRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ListenerRule `json:"items"`
}

// Repository type metadata.
var (
	ListenerRule_Kind             = "ListenerRule"
	ListenerRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ListenerRule_Kind}.String()
	ListenerRule_KindAPIVersion   = ListenerRule_Kind + "." + CRDGroupVersion.String()
	ListenerRule_GroupVersionKind = CRDGroupVersion.WithKind(ListenerRule_Kind)
)

func init() {
	SchemeBuilder.Register(&ListenerRule{}, &ListenerRuleList{})
}
